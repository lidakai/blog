{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/diaspora/source/css/diaspora.css","path":"css/diaspora.css","modified":1,"renderable":1},{"_id":"themes/diaspora/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/diaspora/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/diaspora/source/js/diaspora.js","path":"js/diaspora.js","modified":1,"renderable":1},{"_id":"themes/diaspora/source/js/plugin.js","path":"js/plugin.js","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.js","path":"photoswipe/photoswipe-ui-default.js","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.min.js","path":"photoswipe/photoswipe-ui-default.min.js","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe.css","path":"photoswipe/photoswipe.css","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe.min.js","path":"photoswipe/photoswipe.min.js","modified":1,"renderable":1},{"_id":"themes/diaspora/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe.js","path":"photoswipe/photoswipe.js","modified":1,"renderable":1},{"_id":"themes/diaspora/source/img/cover.jpg","path":"img/cover.jpg","modified":1,"renderable":1},{"_id":"themes/diaspora/source/img/welcome-cover.jpg","path":"img/welcome-cover.jpg","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.svg","path":"photoswipe/default-skin/default-skin.svg","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.png","path":"photoswipe/default-skin/default-skin.png","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/preloader.gif","path":"photoswipe/default-skin/preloader.gif","modified":1,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.css","path":"photoswipe/default-skin/default-skin.css","modified":1,"renderable":1}],"Cache":[{"_id":"themes/diaspora/.gitignore","hash":"39e91775f38f3dbe2cf60219af92ecb8af58f783","modified":1554952112427},{"_id":"themes/diaspora/LICENSE","hash":"6d3068ec88faa33b77e425407a5bc050d96914dc","modified":1554952112427},{"_id":"themes/diaspora/README.md","hash":"79a357d253597cecce786da3dabcb535bdba4d91","modified":1554952112428},{"_id":"themes/diaspora/_config.yml","hash":"37d0208e2591e24f79d71e8c5edc9b541c52ccd3","modified":1555381324042},{"_id":"source/_posts/hello-world-day0.md","hash":"e1c2a57414663a883c1ca6c5ff098bd38c937ae0","modified":1556012970235},{"_id":"source/_posts/puppeteer-day1.md","hash":"4631e8451cbecf38bf64cafd5d81995438937eaa","modified":1556011500990},{"_id":"source/_posts/前端性能优化点-day05.md","hash":"aeb661e23f003f88980055f93fe0e609be0165fb","modified":1556012960219},{"_id":"source/_posts/前端性能优化相关编码规范-day04.md","hash":"6f6e78e5f2e87add9aefe6eebd1f1d7961db01e6","modified":1556012510339},{"_id":"source/_posts/前端规范-dya03.md","hash":"ebb4d6823562d543e9656c980b796fee75c7a7ed","modified":1556012512421},{"_id":"source/tags/index.md","hash":"9866730123a2c422a98393937ca3f26ee3a57b3e","modified":1555380096346},{"_id":"source/other/index.md","hash":"22e57ca812fa45f417d503ab9a05de391505c8e5","modified":1555378441649},{"_id":"source/categories/index.md","hash":"2814666223fe439617925403e609bca7397413dc","modified":1555378973162},{"_id":"themes/diaspora/languages/default.yml","hash":"cb49d6c405ac17b25c8822bc0050fabdf03ae535","modified":1554952112429},{"_id":"themes/diaspora/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1554952112430},{"_id":"themes/diaspora/languages/it.yml","hash":"2b5323867169b25e52009696680a12811b226c1e","modified":1554952112430},{"_id":"themes/diaspora/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1554952112431},{"_id":"themes/diaspora/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1554952112431},{"_id":"themes/diaspora/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1554952112432},{"_id":"themes/diaspora/languages/zh-CN.yml","hash":"a10d783759847b5c2fc460f3e99000588e76d7ea","modified":1554952112433},{"_id":"themes/diaspora/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1554952112433},{"_id":"themes/diaspora/layout/archive.ejs","hash":"ea4e20aa5b13ea8c615b28607a123ca1ee2dfbc5","modified":1554952112446},{"_id":"themes/diaspora/layout/category.ejs","hash":"a0cfecbd3216ebeb7e252b5307dfa0f580742d8c","modified":1554952112446},{"_id":"themes/diaspora/layout/index.ejs","hash":"9990bb75766b8888c81dac670fc2ffa1c178c883","modified":1554952112447},{"_id":"themes/diaspora/layout/layout.ejs","hash":"6ae230910cd17f113af54704bdc4774f265d9e4e","modified":1554952112447},{"_id":"themes/diaspora/layout/page.ejs","hash":"02d3e512e4c1fcb8fd68361b142f71d700c21c34","modified":1554952112448},{"_id":"themes/diaspora/layout/post.ejs","hash":"a463095027c4f25ed44bb7dc9514b46d99e381c8","modified":1554952112448},{"_id":"themes/diaspora/layout/tag.ejs","hash":"a0cfecbd3216ebeb7e252b5307dfa0f580742d8c","modified":1554952112449},{"_id":"themes/diaspora/scripts/page_title.js","hash":"3cf8cded8642f91782f226ea0fc4318b1859640c","modified":1554952112450},{"_id":"themes/diaspora/layout/_partial/categories.ejs","hash":"11bf044f3fefe42d4aa3f2205d4a3be8a8138953","modified":1554952112434},{"_id":"themes/diaspora/layout/_partial/google-analytics.ejs","hash":"d50db25113e28754bcfe109b4ea784ee68bc3bde","modified":1554952112435},{"_id":"themes/diaspora/layout/_partial/head.ejs","hash":"6cbd305d6d5d80316d07b2dbef500dfd7f67a19c","modified":1554952112435},{"_id":"themes/diaspora/layout/_partial/list.ejs","hash":"3d01f5eead06f278ed51664ced705679d1248f7b","modified":1554952112436},{"_id":"themes/diaspora/layout/_partial/menu.ejs","hash":"08b45261ca8f80dc1ec5b30ac4bd532822d3e652","modified":1554952112437},{"_id":"themes/diaspora/layout/_partial/pagination.ejs","hash":"f561e68e9dd10ae1cf2e79e8425f7e9b86ed723e","modified":1554952112437},{"_id":"themes/diaspora/layout/_partial/photoswipe.ejs","hash":"bb76ab13612d56211278c46746e6646034e9ee68","modified":1554952112438},{"_id":"themes/diaspora/layout/_partial/screen.ejs","hash":"7d78e085d3b3913b16d88ea61e245599f7e58b0c","modified":1554952112443},{"_id":"themes/diaspora/layout/_partial/scripts.ejs","hash":"670900a4d225ce2771dc739fcf7a674b06f0ac38","modified":1554952112444},{"_id":"themes/diaspora/layout/_partial/tags.ejs","hash":"3f78d2fe0385487dee1efd1fc5cdd4aeca649ab5","modified":1554952112445},{"_id":"themes/diaspora/source/css/diaspora.css","hash":"f94add4dfc251bc4e6c07e9e53e214c4574ee9ac","modified":1554952112452},{"_id":"themes/diaspora/source/img/favicon.ico","hash":"805d8a797cbaf227e52c1aa81e5f370aa6875f01","modified":1554952333590},{"_id":"themes/diaspora/source/img/logo.png","hash":"a2fde75b8e017ae1c02d5615811ff5a96b56e4b7","modified":1554952028342},{"_id":"themes/diaspora/source/js/diaspora.js","hash":"107843b6970c9ba1ff377fd3137d67e050bd9cad","modified":1554952112457},{"_id":"themes/diaspora/source/js/plugin.js","hash":"2e2108dc052d5e96ace35f091d8dbecd5f587b65","modified":1554952112459},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.js","hash":"2a606363f7ff46d67cd93fa0932dca8d5a48bd20","modified":1554952112463},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.min.js","hash":"b34f592dc9765f1e6f91343197a623dfb7acfaab","modified":1554952112464},{"_id":"themes/diaspora/source/photoswipe/photoswipe.css","hash":"e6d93b786de172eca4fbd96527cc0dadd202aee6","modified":1554952112465},{"_id":"themes/diaspora/source/photoswipe/photoswipe.min.js","hash":"def03cfc3e7333b081e4cea1508bab3015e860c9","modified":1554952112467},{"_id":"themes/diaspora/source/js/jquery.min.js","hash":"cf9b759270c1c7c603d8d3879d2c5fabc621d004","modified":1554952112458},{"_id":"themes/diaspora/source/photoswipe/photoswipe.js","hash":"37db9dbd8d3a4025a817982fc02c0140d69ca6c4","modified":1554952112466},{"_id":"themes/diaspora/layout/_partial/post/article.ejs","hash":"96e962f78ef989c1a4b07a28d527e2d6f616711b","modified":1554952112439},{"_id":"themes/diaspora/layout/_partial/post/date.ejs","hash":"bb624f77d29594b8d3a7dd82f1aee6eead6b9b61","modified":1554952112440},{"_id":"themes/diaspora/layout/_partial/post/gitalk.ejs","hash":"ecbbf317fbb9824388c46c4049582f0a65ec1d01","modified":1554952112441},{"_id":"themes/diaspora/layout/_partial/post/header.ejs","hash":"6541cd330fbc6a709d5b383283ea3619d9f26a72","modified":1554952112441},{"_id":"themes/diaspora/layout/_partial/post/item.ejs","hash":"db2d7aafe41e0e579964bc6303e54f9b3f03127a","modified":1554952112442},{"_id":"themes/diaspora/layout/_partial/post/tag.ejs","hash":"00398c91d88a106301cac57f821a113b66f4fb2a","modified":1554952112442},{"_id":"themes/diaspora/layout/_partial/post/title.ejs","hash":"fc807200c48d99b510ca38699506af67df2d81e6","modified":1554952112443},{"_id":"themes/diaspora/source/img/cover.jpg","hash":"dc7103d4c4e05650595712b3fa395b89726df32b","modified":1554952112454},{"_id":"themes/diaspora/source/img/welcome-cover.jpg","hash":"c393dfeb52aff20a9921c1f56e2ce127683ab35a","modified":1554952112456},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1554952112462},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1554952112461},{"_id":"themes/diaspora/source/photoswipe/default-skin/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1554952112462},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.css","hash":"9106e9fabb78ef1ce4cc896cfec003fcbd9e1256","modified":1554952112461},{"_id":"public/tags/index.html","hash":"74eb94b20fff6b1cde44b98a366a9d50f5de0a6f","modified":1556012993785},{"_id":"public/other/index.html","hash":"e81af941f50c2a5d682d5a627eaa777e16118924","modified":1556012993785},{"_id":"public/categories/index.html","hash":"3fb52f5d92e9fbd34687368e24d37145baa7b076","modified":1556012993785},{"_id":"public/2018/04/10/puppeteer-day1/index.html","hash":"b29feeb907135bbc47315eae3aee2c28c33a49cd","modified":1556012993786},{"_id":"public/2018/04/10/hello-world-day0/index.html","hash":"dfe5aab17c1376ad2377c90e26ca2af6400b1c86","modified":1556012993786},{"_id":"public/archives/index.html","hash":"c897f93645db019e36545fee8b4dd790f609c1a8","modified":1556012993786},{"_id":"public/archives/2018/index.html","hash":"13d0d29b8477176d736d00fbd87dffc3b3aaccb4","modified":1556012993786},{"_id":"public/archives/2018/04/index.html","hash":"f6f2c71bf77073bf9e1ec59ab161a1f2be4a9527","modified":1556012993786},{"_id":"public/archives/2018/05/index.html","hash":"74374cdf5ec6925bb27a6533ac3c2e34fad52137","modified":1556012993786},{"_id":"public/archives/2018/06/index.html","hash":"5dd411a46ee956eded18a4cb7a6af9d0a8d72a17","modified":1556012993786},{"_id":"public/archives/2018/08/index.html","hash":"2a4903434e90c8f1081cf9e4ac6edcc2d80e596f","modified":1556012993786},{"_id":"public/categories/大杂烩/index.html","hash":"dbbcb319bb7ddfa59745b1d7dc0c5dee7006d7a5","modified":1556012993786},{"_id":"public/tags/NodeJs/index.html","hash":"8009cb0eb4958d579229576737c2606a3b478e86","modified":1556012993786},{"_id":"public/tags/前端工程化/index.html","hash":"ec4ee2e71c425a0273a3728a2767da9b7147f395","modified":1556012993786},{"_id":"public/tags/前端性能/index.html","hash":"94c991596ee9d648e093a4c4536447110e86e14a","modified":1556012993786},{"_id":"public/tags/前端规范/index.html","hash":"67c93ffc6ce9334a24338930972577b0c68a5e24","modified":1556012993786},{"_id":"public/index.html","hash":"241f802da0fcea2e392d7e8683835b7506352248","modified":1556012993786},{"_id":"public/2018/08/02/前端性能优化点-day05/index.html","hash":"79a9f96960728a202093c5529986477705172218","modified":1556012993787},{"_id":"public/2018/06/22/前端性能优化相关编码规范-day04/index.html","hash":"49b5fe44f6b9c796466cdfc471fead32f8e71fb8","modified":1556012993787},{"_id":"public/2018/05/12/前端规范-dya03/index.html","hash":"8763e248ca1870bda781ea995a9aaad60467112b","modified":1556012993787},{"_id":"public/img/favicon.ico","hash":"805d8a797cbaf227e52c1aa81e5f370aa6875f01","modified":1556012993803},{"_id":"public/img/logo.png","hash":"a2fde75b8e017ae1c02d5615811ff5a96b56e4b7","modified":1556012993803},{"_id":"public/photoswipe/default-skin/default-skin.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1556012993803},{"_id":"public/photoswipe/default-skin/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1556012993803},{"_id":"public/photoswipe/default-skin/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1556012993803},{"_id":"public/photoswipe/photoswipe-ui-default.min.js","hash":"d80b713ca1bab90f27a8af7d8e43563f0fe81860","modified":1556012993827},{"_id":"public/photoswipe/photoswipe.css","hash":"a31fa495095783ef5a84ba4dba0bd6f7de3b07ea","modified":1556012993827},{"_id":"public/photoswipe/default-skin/default-skin.css","hash":"5763bd1a8015774f37215359bfcb5edd65d198a6","modified":1556012993828},{"_id":"public/css/diaspora.css","hash":"7de3f43e4084e4594cdefb3ac36b0e628987c25b","modified":1556012993828},{"_id":"public/js/diaspora.js","hash":"559740e9f119855dcd4b94435c8bc532ba7caeb3","modified":1556012993828},{"_id":"public/js/plugin.js","hash":"0ac6bf36a9a11ca6fad0af1f20e5705bc326abf4","modified":1556012993829},{"_id":"public/photoswipe/photoswipe.min.js","hash":"791703278e7c576b08b67f18404bae9eb8cebfaf","modified":1556012993829},{"_id":"public/photoswipe/photoswipe-ui-default.js","hash":"c844cca2f9a9969a810a0fb534063e008424c936","modified":1556012993829},{"_id":"public/js/jquery.min.js","hash":"3f1b0e9e54af1af2db2c8a639530448723462151","modified":1556012993829},{"_id":"public/photoswipe/photoswipe.js","hash":"30967789eb2a3e1da9927e71f4f3c5339ebed39a","modified":1556012993829},{"_id":"public/img/cover.jpg","hash":"dc7103d4c4e05650595712b3fa395b89726df32b","modified":1556012993829},{"_id":"public/img/welcome-cover.jpg","hash":"c393dfeb52aff20a9921c1f56e2ce127683ab35a","modified":1556012993829}],"Category":[{"name":"大杂烩","_id":"cjutlylfy0004zcum1oz5lgc4"}],"Data":[],"Page":[{"title":"tags","date":"2019-04-10T10:42:16.000Z","type":"tags","_content":"#nodeJs\ncss\njavascript\nhtml","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-04-10 18:42:16\ntype: \"tags\"\n---\n#nodeJs\ncss\njavascript\nhtml","updated":"2019-04-16T02:01:36.346Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjutlylgr000mzcumuxog28av","content":"<p>#nodeJs<br>css<br>javascript<br>html</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#nodeJs<br>css<br>javascript<br>html</p>\n"},{"title":"other","date":"2019-04-10T10:42:16.000Z","type":"other","_content":"这是一篇个人简介","source":"other/index.md","raw":"---\ntitle: other\ndate: 2019-04-10 18:42:16\ntype: \"other\"\n---\n这是一篇个人简介","updated":"2019-04-16T01:34:01.649Z","path":"other/index.html","comments":1,"layout":"page","_id":"cjutlylgu000nzcum9u1e9jt6","content":"<p>这是一篇个人简介</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一篇个人简介</p>\n"},{"title":"大杂烩","date":"2019-04-10T10:40:49.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\n# 分类\ntitle: 大杂烩\ndate: 2019-04-10 18:40:49\ntype: \"categories\"\n---","updated":"2019-04-16T01:42:53.162Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjutlylgw000ozcum31m5yfmo","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"高级爬虫--Puppeteer初探","date":"2018-04-10T10:56:55.000Z","cover":"http://www.alibibi.top/image/lm.jpg","_content":"### 首先介绍Puppeteer\n* Puppeteer是一个node库，他提供了一组用来操纵Chrome的API，理论上使用它可以做任何Chrome可以做的事\n* 有点类似于PhantomJS，但Puppeteer由Chrome官方团队进行维护，前景更好\n* Puppeteer的应用场景会非常多，就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关\n* [Puppeteer官方文档请猛戳这里](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions)\n\n### Puppeteer 核心功能\n1. 利用网页生成PDF、图片\n2. 爬取SPA应用，并生成预渲染内容（即“SSR” 服务端渲染）\n3. 可以从网站抓取内容\n4. 自动化表单提交、UI测试、键盘输入等\n5. 帮你创建一个最新的自动化测试环境（chrome），可以直接在此运行测试用例\n6. 捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题\n\n## 基本熟悉之后，接下来进行Puppeteer的爬虫教学：\n1. 运行Puppeteer\n```\npuppeteer.launch().then(async browser => {\n  ......\n  what you want\n  ......\n})\n```\n2. 跳转至 [阮一峰老师的ES6博客](http://es6.ruanyifeng.com/#README)\n```\nlet page = await browser.newPage();\nawait page.goto('http://es6.ruanyifeng.com/#README');\n```\n3. 分析博客左侧导航栏的dom结构，并拿到所有链接的href、title信息\n```\nlet as = [...document.querySelectorAll('ol li a')];\nreturn as.map((a) =>{\n    return {\n      href: a.href.trim(),\n      name: a.text\n    }\n});\n```\n4. 使用Puppeteer打印当前页面的PDF\n```\nawait page.pdf({path: `./es6-pdf/${aTags[0].name}.pdf`});\n```\n5. 完整代码在: [https://github.com/zhentaoo/puppeteer-deep](https://github.com/zhentaoo/puppeteer-deep)\n6. 项目运行\n* git clone https://github.com/zhentaoo/puppeteer-deep\n* npm install (puppeteer在win下100+M、mac下70+M，请耐心等候)\n* npm run es6\n\n## 最终效果如下，不过要注意几个问题：\n1. 如果在page go之后马上进行pdf抓取，此时页面还未完成渲染，只能抓到loading图（如下），所以需要用timeout做点简单处理\n![示例](http://www.zhentaoo.com/img/puppeteer.png \"示例\")\n2. 最终爬取效果如下，PDF的尺寸、预览效果、首页重复就不做过多整理， 预览效果如下,如果想要自己处理，可以设置一下chrome尺寸，打印页数\n![示例](http://www.zhentaoo.com/img/es6-pdf.png \"示例\")\n![示例](http://www.zhentaoo.com/img/es6.png \"示例\")\n\n##### 最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我….\n\n\nps:\n文章来源自[javascript瞭望塔](http://www.zhentaoo.com/2017/08/17/Puppeteer/)","source":"_posts/puppeteer-day1.md","raw":"---\ntitle: 高级爬虫--Puppeteer初探\ndate: 2018-04-10 18:56:55\ntags: \n    - NodeJs\ncover: http://www.alibibi.top/image/lm.jpg\n---\n### 首先介绍Puppeteer\n* Puppeteer是一个node库，他提供了一组用来操纵Chrome的API，理论上使用它可以做任何Chrome可以做的事\n* 有点类似于PhantomJS，但Puppeteer由Chrome官方团队进行维护，前景更好\n* Puppeteer的应用场景会非常多，就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关\n* [Puppeteer官方文档请猛戳这里](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions)\n\n### Puppeteer 核心功能\n1. 利用网页生成PDF、图片\n2. 爬取SPA应用，并生成预渲染内容（即“SSR” 服务端渲染）\n3. 可以从网站抓取内容\n4. 自动化表单提交、UI测试、键盘输入等\n5. 帮你创建一个最新的自动化测试环境（chrome），可以直接在此运行测试用例\n6. 捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题\n\n## 基本熟悉之后，接下来进行Puppeteer的爬虫教学：\n1. 运行Puppeteer\n```\npuppeteer.launch().then(async browser => {\n  ......\n  what you want\n  ......\n})\n```\n2. 跳转至 [阮一峰老师的ES6博客](http://es6.ruanyifeng.com/#README)\n```\nlet page = await browser.newPage();\nawait page.goto('http://es6.ruanyifeng.com/#README');\n```\n3. 分析博客左侧导航栏的dom结构，并拿到所有链接的href、title信息\n```\nlet as = [...document.querySelectorAll('ol li a')];\nreturn as.map((a) =>{\n    return {\n      href: a.href.trim(),\n      name: a.text\n    }\n});\n```\n4. 使用Puppeteer打印当前页面的PDF\n```\nawait page.pdf({path: `./es6-pdf/${aTags[0].name}.pdf`});\n```\n5. 完整代码在: [https://github.com/zhentaoo/puppeteer-deep](https://github.com/zhentaoo/puppeteer-deep)\n6. 项目运行\n* git clone https://github.com/zhentaoo/puppeteer-deep\n* npm install (puppeteer在win下100+M、mac下70+M，请耐心等候)\n* npm run es6\n\n## 最终效果如下，不过要注意几个问题：\n1. 如果在page go之后马上进行pdf抓取，此时页面还未完成渲染，只能抓到loading图（如下），所以需要用timeout做点简单处理\n![示例](http://www.zhentaoo.com/img/puppeteer.png \"示例\")\n2. 最终爬取效果如下，PDF的尺寸、预览效果、首页重复就不做过多整理， 预览效果如下,如果想要自己处理，可以设置一下chrome尺寸，打印页数\n![示例](http://www.zhentaoo.com/img/es6-pdf.png \"示例\")\n![示例](http://www.zhentaoo.com/img/es6.png \"示例\")\n\n##### 最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我….\n\n\nps:\n文章来源自[javascript瞭望塔](http://www.zhentaoo.com/2017/08/17/Puppeteer/)","slug":"puppeteer-day1","published":1,"updated":"2019-04-23T09:25:00.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjutlylfa0000zcumnk6vcmxl","content":"<h3 id=\"首先介绍Puppeteer\"><a href=\"#首先介绍Puppeteer\" class=\"headerlink\" title=\"首先介绍Puppeteer\"></a>首先介绍Puppeteer</h3><ul>\n<li>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API，理论上使用它可以做任何Chrome可以做的事</li>\n<li>有点类似于PhantomJS，但Puppeteer由Chrome官方团队进行维护，前景更好</li>\n<li>Puppeteer的应用场景会非常多，就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关</li>\n<li><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions\" target=\"_blank\" rel=\"noopener\">Puppeteer官方文档请猛戳这里</a></li>\n</ul>\n<h3 id=\"Puppeteer-核心功能\"><a href=\"#Puppeteer-核心功能\" class=\"headerlink\" title=\"Puppeteer 核心功能\"></a>Puppeteer 核心功能</h3><ol>\n<li>利用网页生成PDF、图片</li>\n<li>爬取SPA应用，并生成预渲染内容（即“SSR” 服务端渲染）</li>\n<li>可以从网站抓取内容</li>\n<li>自动化表单提交、UI测试、键盘输入等</li>\n<li>帮你创建一个最新的自动化测试环境（chrome），可以直接在此运行测试用例</li>\n<li>捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题</li>\n</ol>\n<h2 id=\"基本熟悉之后，接下来进行Puppeteer的爬虫教学：\"><a href=\"#基本熟悉之后，接下来进行Puppeteer的爬虫教学：\" class=\"headerlink\" title=\"基本熟悉之后，接下来进行Puppeteer的爬虫教学：\"></a>基本熟悉之后，接下来进行Puppeteer的爬虫教学：</h2><ol>\n<li><p>运行Puppeteer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">puppeteer.launch().then(async browser =&gt; &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  what you want</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>跳转至 <a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">阮一峰老师的ES6博客</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let page = await browser.newPage();</span><br><span class=\"line\">await page.goto(&apos;http://es6.ruanyifeng.com/#README&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分析博客左侧导航栏的dom结构，并拿到所有链接的href、title信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let as = [...document.querySelectorAll(&apos;ol li a&apos;)];</span><br><span class=\"line\">return as.map((a) =&gt;&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      href: a.href.trim(),</span><br><span class=\"line\">      name: a.text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用Puppeteer打印当前页面的PDF</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await page.pdf(&#123;path: `./es6-pdf/$&#123;aTags[0].name&#125;.pdf`&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完整代码在: <a href=\"https://github.com/zhentaoo/puppeteer-deep\" target=\"_blank\" rel=\"noopener\">https://github.com/zhentaoo/puppeteer-deep</a></p>\n</li>\n<li>项目运行</li>\n</ol>\n<ul>\n<li>git clone <a href=\"https://github.com/zhentaoo/puppeteer-deep\" target=\"_blank\" rel=\"noopener\">https://github.com/zhentaoo/puppeteer-deep</a></li>\n<li>npm install (puppeteer在win下100+M、mac下70+M，请耐心等候)</li>\n<li>npm run es6</li>\n</ul>\n<h2 id=\"最终效果如下，不过要注意几个问题：\"><a href=\"#最终效果如下，不过要注意几个问题：\" class=\"headerlink\" title=\"最终效果如下，不过要注意几个问题：\"></a>最终效果如下，不过要注意几个问题：</h2><ol>\n<li>如果在page go之后马上进行pdf抓取，此时页面还未完成渲染，只能抓到loading图（如下），所以需要用timeout做点简单处理<br><img src=\"http://www.zhentaoo.com/img/puppeteer.png\" alt=\"示例\" title=\"示例\"></li>\n<li>最终爬取效果如下，PDF的尺寸、预览效果、首页重复就不做过多整理， 预览效果如下,如果想要自己处理，可以设置一下chrome尺寸，打印页数<br><img src=\"http://www.zhentaoo.com/img/es6-pdf.png\" alt=\"示例\" title=\"示例\"><br><img src=\"http://www.zhentaoo.com/img/es6.png\" alt=\"示例\" title=\"示例\"></li>\n</ol>\n<h5 id=\"最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我…\"><a href=\"#最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我…\" class=\"headerlink\" title=\"最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我….\"></a>最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我….</h5><p>ps:<br>文章来源自<a href=\"http://www.zhentaoo.com/2017/08/17/Puppeteer/\" target=\"_blank\" rel=\"noopener\">javascript瞭望塔</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"首先介绍Puppeteer\"><a href=\"#首先介绍Puppeteer\" class=\"headerlink\" title=\"首先介绍Puppeteer\"></a>首先介绍Puppeteer</h3><ul>\n<li>Puppeteer是一个node库，他提供了一组用来操纵Chrome的API，理论上使用它可以做任何Chrome可以做的事</li>\n<li>有点类似于PhantomJS，但Puppeteer由Chrome官方团队进行维护，前景更好</li>\n<li>Puppeteer的应用场景会非常多，就爬虫领域来说，远比一般的爬虫工具功能更丰富，性能分析、自动化测试也不在话下，今天先探讨爬虫相关</li>\n<li><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions\" target=\"_blank\" rel=\"noopener\">Puppeteer官方文档请猛戳这里</a></li>\n</ul>\n<h3 id=\"Puppeteer-核心功能\"><a href=\"#Puppeteer-核心功能\" class=\"headerlink\" title=\"Puppeteer 核心功能\"></a>Puppeteer 核心功能</h3><ol>\n<li>利用网页生成PDF、图片</li>\n<li>爬取SPA应用，并生成预渲染内容（即“SSR” 服务端渲染）</li>\n<li>可以从网站抓取内容</li>\n<li>自动化表单提交、UI测试、键盘输入等</li>\n<li>帮你创建一个最新的自动化测试环境（chrome），可以直接在此运行测试用例</li>\n<li>捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题</li>\n</ol>\n<h2 id=\"基本熟悉之后，接下来进行Puppeteer的爬虫教学：\"><a href=\"#基本熟悉之后，接下来进行Puppeteer的爬虫教学：\" class=\"headerlink\" title=\"基本熟悉之后，接下来进行Puppeteer的爬虫教学：\"></a>基本熟悉之后，接下来进行Puppeteer的爬虫教学：</h2><ol>\n<li><p>运行Puppeteer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">puppeteer.launch().then(async browser =&gt; &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  what you want</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>跳转至 <a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">阮一峰老师的ES6博客</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let page = await browser.newPage();</span><br><span class=\"line\">await page.goto(&apos;http://es6.ruanyifeng.com/#README&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分析博客左侧导航栏的dom结构，并拿到所有链接的href、title信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let as = [...document.querySelectorAll(&apos;ol li a&apos;)];</span><br><span class=\"line\">return as.map((a) =&gt;&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      href: a.href.trim(),</span><br><span class=\"line\">      name: a.text</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用Puppeteer打印当前页面的PDF</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await page.pdf(&#123;path: `./es6-pdf/$&#123;aTags[0].name&#125;.pdf`&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完整代码在: <a href=\"https://github.com/zhentaoo/puppeteer-deep\" target=\"_blank\" rel=\"noopener\">https://github.com/zhentaoo/puppeteer-deep</a></p>\n</li>\n<li>项目运行</li>\n</ol>\n<ul>\n<li>git clone <a href=\"https://github.com/zhentaoo/puppeteer-deep\" target=\"_blank\" rel=\"noopener\">https://github.com/zhentaoo/puppeteer-deep</a></li>\n<li>npm install (puppeteer在win下100+M、mac下70+M，请耐心等候)</li>\n<li>npm run es6</li>\n</ul>\n<h2 id=\"最终效果如下，不过要注意几个问题：\"><a href=\"#最终效果如下，不过要注意几个问题：\" class=\"headerlink\" title=\"最终效果如下，不过要注意几个问题：\"></a>最终效果如下，不过要注意几个问题：</h2><ol>\n<li>如果在page go之后马上进行pdf抓取，此时页面还未完成渲染，只能抓到loading图（如下），所以需要用timeout做点简单处理<br><img src=\"http://www.zhentaoo.com/img/puppeteer.png\" alt=\"示例\" title=\"示例\"></li>\n<li>最终爬取效果如下，PDF的尺寸、预览效果、首页重复就不做过多整理， 预览效果如下,如果想要自己处理，可以设置一下chrome尺寸，打印页数<br><img src=\"http://www.zhentaoo.com/img/es6-pdf.png\" alt=\"示例\" title=\"示例\"><br><img src=\"http://www.zhentaoo.com/img/es6.png\" alt=\"示例\" title=\"示例\"></li>\n</ol>\n<h5 id=\"最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我…\"><a href=\"#最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我…\" class=\"headerlink\" title=\"最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我….\"></a>最后声明，生成的PDF很粗糙，应该不会对阮老师产生什么影响，如有问题可以第一时间联系我….</h5><p>ps:<br>文章来源自<a href=\"http://www.zhentaoo.com/2017/08/17/Puppeteer/\" target=\"_blank\" rel=\"noopener\">javascript瞭望塔</a></p>\n"},{"title":"前端性能","date":"2018-04-10T10:56:55.000Z","cover":"http://www.alibibi.top/image/day4.jpg","_content":"关于前端性能优化的文章数不胜数，有从各个角度切入，也有单抓某点持续深入探讨的。\n由于个人喜欢纵观全局式的学习，因此这里从多个角度整理、分析前端性能优化可行的一些方案。\n以下内容有不少是从其他地方摘录、整理而来的，在文末我会把一些比较全面重要的资料\n提供出来，供大家参考学习。\n\n### 性能评估指标\n\n1. 首屏时间\n浏览器显示第一屏页面所消耗的时间，以800x600像素尺寸为标准，从开始加载到浏览器页面显示高度达到600像素且此区域有内容显示的时间。\n工信部在《宽带速率的测试方法用户上网体验》规范标准中采用“首屏时间”指标。\n\n2. 用户体验评估标准\n一个页面的“总加载时间”要比“首屏时间”长，但对于最终用户体验而言，当内容充满首屏的区域时，用户就可以看到网站的主要内容并可以进行各自的选择了。首屏时间的快与慢，直接影响到了用户对网站的认知度。\n在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了\n\n3. 白屏时间\n这个其实不多说，读者也明白，就是页面处于空白的时间。页面空白，用户就会焦躁，并且变得不耐心。影响白屏时间的多数是：DNS解析耗时+服务端耗时+网络传输耗时。\n\n4. 用户可操作时间\n顾名思义，这项指标值得是，我们的网页用户可以使用的时间。一般来讲 domready时间，便是我们的用户可操作时间了。\n\n5. 总下载时间\n通常指，页面总体的下载时间，所有的页面资源都下载完成。\n\n6. 推荐资料\n[聊一聊前端速度统计(性能统计)那些事儿](https://segmentfault.com/a/1190000005869953)\n[WEB前端性能优化常见方法](https://segmentfault.com/a/1190000008829958)\n\n### 优化策略\n1. 减少http请求\n在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。一个正常HTTP请求的流程简述：如在浏览器中输入_www.xxxxxx.com_\n并按下回车，经过DNS查找，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。\n而当我们请求的网页文件中有很多图片、CSS、JS甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个HTTP请求都会对服务器和浏览器产生性能负担。\n网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。\n\n合并图片，图片降质\n\n2. 代码压缩\nwebpack CommonChunkPlygin Uglify CSS，JS代码压缩，混淆\n\n合理利用Localstorage\n\nnginx开启Gzip可减小文件60%－70%体积\n\n3. 推荐资料\n[https://segmentfault.com/a/1190000003646305#articleHeader28](https://segmentfault.com/a/1190000003646305#articleHeader28)\n[https://github.com/kangkk/web_performance_optimization](https://github.com/kangkk/web_performance_optimization)","source":"_posts/hello-world-day0.md","raw":"---\ntitle: 前端性能\ndate: 2018-04-10 18:56:55\ntags: \n    - 前端工程化\ncategories: \n    - 大杂烩\ncover: http://www.alibibi.top/image/day4.jpg\n---\n关于前端性能优化的文章数不胜数，有从各个角度切入，也有单抓某点持续深入探讨的。\n由于个人喜欢纵观全局式的学习，因此这里从多个角度整理、分析前端性能优化可行的一些方案。\n以下内容有不少是从其他地方摘录、整理而来的，在文末我会把一些比较全面重要的资料\n提供出来，供大家参考学习。\n\n### 性能评估指标\n\n1. 首屏时间\n浏览器显示第一屏页面所消耗的时间，以800x600像素尺寸为标准，从开始加载到浏览器页面显示高度达到600像素且此区域有内容显示的时间。\n工信部在《宽带速率的测试方法用户上网体验》规范标准中采用“首屏时间”指标。\n\n2. 用户体验评估标准\n一个页面的“总加载时间”要比“首屏时间”长，但对于最终用户体验而言，当内容充满首屏的区域时，用户就可以看到网站的主要内容并可以进行各自的选择了。首屏时间的快与慢，直接影响到了用户对网站的认知度。\n在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了\n\n3. 白屏时间\n这个其实不多说，读者也明白，就是页面处于空白的时间。页面空白，用户就会焦躁，并且变得不耐心。影响白屏时间的多数是：DNS解析耗时+服务端耗时+网络传输耗时。\n\n4. 用户可操作时间\n顾名思义，这项指标值得是，我们的网页用户可以使用的时间。一般来讲 domready时间，便是我们的用户可操作时间了。\n\n5. 总下载时间\n通常指，页面总体的下载时间，所有的页面资源都下载完成。\n\n6. 推荐资料\n[聊一聊前端速度统计(性能统计)那些事儿](https://segmentfault.com/a/1190000005869953)\n[WEB前端性能优化常见方法](https://segmentfault.com/a/1190000008829958)\n\n### 优化策略\n1. 减少http请求\n在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。一个正常HTTP请求的流程简述：如在浏览器中输入_www.xxxxxx.com_\n并按下回车，经过DNS查找，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。\n而当我们请求的网页文件中有很多图片、CSS、JS甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个HTTP请求都会对服务器和浏览器产生性能负担。\n网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。\n\n合并图片，图片降质\n\n2. 代码压缩\nwebpack CommonChunkPlygin Uglify CSS，JS代码压缩，混淆\n\n合理利用Localstorage\n\nnginx开启Gzip可减小文件60%－70%体积\n\n3. 推荐资料\n[https://segmentfault.com/a/1190000003646305#articleHeader28](https://segmentfault.com/a/1190000003646305#articleHeader28)\n[https://github.com/kangkk/web_performance_optimization](https://github.com/kangkk/web_performance_optimization)","slug":"hello-world-day0","published":1,"updated":"2019-04-23T09:49:30.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjutlylfh0001zcumztqozr5x","content":"<p>关于前端性能优化的文章数不胜数，有从各个角度切入，也有单抓某点持续深入探讨的。<br>由于个人喜欢纵观全局式的学习，因此这里从多个角度整理、分析前端性能优化可行的一些方案。<br>以下内容有不少是从其他地方摘录、整理而来的，在文末我会把一些比较全面重要的资料<br>提供出来，供大家参考学习。</p>\n<h3 id=\"性能评估指标\"><a href=\"#性能评估指标\" class=\"headerlink\" title=\"性能评估指标\"></a>性能评估指标</h3><ol>\n<li><p>首屏时间<br>浏览器显示第一屏页面所消耗的时间，以800x600像素尺寸为标准，从开始加载到浏览器页面显示高度达到600像素且此区域有内容显示的时间。<br>工信部在《宽带速率的测试方法用户上网体验》规范标准中采用“首屏时间”指标。</p>\n</li>\n<li><p>用户体验评估标准<br>一个页面的“总加载时间”要比“首屏时间”长，但对于最终用户体验而言，当内容充满首屏的区域时，用户就可以看到网站的主要内容并可以进行各自的选择了。首屏时间的快与慢，直接影响到了用户对网站的认知度。<br>在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了</p>\n</li>\n<li><p>白屏时间<br>这个其实不多说，读者也明白，就是页面处于空白的时间。页面空白，用户就会焦躁，并且变得不耐心。影响白屏时间的多数是：DNS解析耗时+服务端耗时+网络传输耗时。</p>\n</li>\n<li><p>用户可操作时间<br>顾名思义，这项指标值得是，我们的网页用户可以使用的时间。一般来讲 domready时间，便是我们的用户可操作时间了。</p>\n</li>\n<li><p>总下载时间<br>通常指，页面总体的下载时间，所有的页面资源都下载完成。</p>\n</li>\n<li><p>推荐资料<br><a href=\"https://segmentfault.com/a/1190000005869953\" target=\"_blank\" rel=\"noopener\">聊一聊前端速度统计(性能统计)那些事儿</a><br><a href=\"https://segmentfault.com/a/1190000008829958\" target=\"_blank\" rel=\"noopener\">WEB前端性能优化常见方法</a></p>\n</li>\n</ol>\n<h3 id=\"优化策略\"><a href=\"#优化策略\" class=\"headerlink\" title=\"优化策略\"></a>优化策略</h3><ol>\n<li>减少http请求<br>在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。一个正常HTTP请求的流程简述：如在浏览器中输入<em><a href=\"http://www.xxxxxx.com\" target=\"_blank\" rel=\"noopener\">www.xxxxxx.com</a></em><br>并按下回车，经过DNS查找，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。<br>而当我们请求的网页文件中有很多图片、CSS、JS甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个HTTP请求都会对服务器和浏览器产生性能负担。<br>网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。</li>\n</ol>\n<p>合并图片，图片降质</p>\n<ol start=\"2\">\n<li>代码压缩<br>webpack CommonChunkPlygin Uglify CSS，JS代码压缩，混淆</li>\n</ol>\n<p>合理利用Localstorage</p>\n<p>nginx开启Gzip可减小文件60%－70%体积</p>\n<ol start=\"3\">\n<li>推荐资料<br><a href=\"https://segmentfault.com/a/1190000003646305#articleHeader28\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000003646305#articleHeader28</a><br><a href=\"https://github.com/kangkk/web_performance_optimization\" target=\"_blank\" rel=\"noopener\">https://github.com/kangkk/web_performance_optimization</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>关于前端性能优化的文章数不胜数，有从各个角度切入，也有单抓某点持续深入探讨的。<br>由于个人喜欢纵观全局式的学习，因此这里从多个角度整理、分析前端性能优化可行的一些方案。<br>以下内容有不少是从其他地方摘录、整理而来的，在文末我会把一些比较全面重要的资料<br>提供出来，供大家参考学习。</p>\n<h3 id=\"性能评估指标\"><a href=\"#性能评估指标\" class=\"headerlink\" title=\"性能评估指标\"></a>性能评估指标</h3><ol>\n<li><p>首屏时间<br>浏览器显示第一屏页面所消耗的时间，以800x600像素尺寸为标准，从开始加载到浏览器页面显示高度达到600像素且此区域有内容显示的时间。<br>工信部在《宽带速率的测试方法用户上网体验》规范标准中采用“首屏时间”指标。</p>\n</li>\n<li><p>用户体验评估标准<br>一个页面的“总加载时间”要比“首屏时间”长，但对于最终用户体验而言，当内容充满首屏的区域时，用户就可以看到网站的主要内容并可以进行各自的选择了。首屏时间的快与慢，直接影响到了用户对网站的认知度。<br>在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了</p>\n</li>\n<li><p>白屏时间<br>这个其实不多说，读者也明白，就是页面处于空白的时间。页面空白，用户就会焦躁，并且变得不耐心。影响白屏时间的多数是：DNS解析耗时+服务端耗时+网络传输耗时。</p>\n</li>\n<li><p>用户可操作时间<br>顾名思义，这项指标值得是，我们的网页用户可以使用的时间。一般来讲 domready时间，便是我们的用户可操作时间了。</p>\n</li>\n<li><p>总下载时间<br>通常指，页面总体的下载时间，所有的页面资源都下载完成。</p>\n</li>\n<li><p>推荐资料<br><a href=\"https://segmentfault.com/a/1190000005869953\" target=\"_blank\" rel=\"noopener\">聊一聊前端速度统计(性能统计)那些事儿</a><br><a href=\"https://segmentfault.com/a/1190000008829958\" target=\"_blank\" rel=\"noopener\">WEB前端性能优化常见方法</a></p>\n</li>\n</ol>\n<h3 id=\"优化策略\"><a href=\"#优化策略\" class=\"headerlink\" title=\"优化策略\"></a>优化策略</h3><ol>\n<li>减少http请求<br>在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。一个正常HTTP请求的流程简述：如在浏览器中输入<em><a href=\"http://www.xxxxxx.com\" target=\"_blank\" rel=\"noopener\">www.xxxxxx.com</a></em><br>并按下回车，经过DNS查找，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。<br>而当我们请求的网页文件中有很多图片、CSS、JS甚至音乐等信息时，将会频繁的与服务器建立连接，与释放连接，这必定会造成资源的浪费，且每个HTTP请求都会对服务器和浏览器产生性能负担。<br>网速相同的条件下，下载一个100KB的图片比下载两个50KB的图片要快。所以，请减少HTTP请求。</li>\n</ol>\n<p>合并图片，图片降质</p>\n<ol start=\"2\">\n<li>代码压缩<br>webpack CommonChunkPlygin Uglify CSS，JS代码压缩，混淆</li>\n</ol>\n<p>合理利用Localstorage</p>\n<p>nginx开启Gzip可减小文件60%－70%体积</p>\n<ol start=\"3\">\n<li>推荐资料<br><a href=\"https://segmentfault.com/a/1190000003646305#articleHeader28\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000003646305#articleHeader28</a><br><a href=\"https://github.com/kangkk/web_performance_optimization\" target=\"_blank\" rel=\"noopener\">https://github.com/kangkk/web_performance_optimization</a></li>\n</ol>\n"},{"title":"前端性能优化点","date":"2018-08-02T04:35:30.000Z","_content":"\n### 目录导航\n\n- [前端性能优化点](#前端性能优化点)\n- [一. HTTP优化](#一-http优化)\n- [1. 减少HTTP请求](#减少http请求)\n- [2. 重定向优化](#重定向优化)\n- [3. 避免死链/空链/404/410错误](#避免死链空链错误)\n- [4. 尽早flush buffer](#尽早flush-buffer)\n- [5. http中的character设置](#http中的character设置)\n\n- [二. 缓存优化](#二-缓存优化)\n- [1. 浏览器缓存](#浏览器缓存)\n- [添加 Expires 或 Cache-Control 头](#添加-expires-或-cache-control-头)\n- [对动态可用缓存使用“身份识别”](#对动态可用缓存使用身份识别)\n- [为IE设置Vary的header](#为ie设置vary的header)\n- [避免firefox中URL造成的缓存冲突](#避免firefox中url造成的缓存冲突)\n\n- [2. 代理服务器(静态资源服务器)缓存](#代理服务器静态资源服务器缓存)\n\n- [三. DNS](#三-dns)\n- [1. 减小DNS解析](#减小dns解析)\n- [2. 增加静态资源域名](#增加静态资源域名)\n\n- [四. 服务器负载优化](#四-服务器负载优化)\n- [1. 使用CND](#使用cnd)\n- [2. Cookie优化](#cookie优化)\n- [3. 使用Gzip](#使用gzip)\n- [4. 压缩文件](#压缩文件)\n\n- [五. CSS相关优化](#五-css相关优化)\n- [1. 样式表合并放头部](#样式表合并放头部)\n- [2. css编码要点](#css编码要点)\n- [3. 使用css Sprite](#使用css-sprite)\n- [4. 外联css](#外联css)\n\n- [六. Javascript相关优化](#六-javascript相关优化)\n- [1. js文件放底部](#js文件放底部)\n- [2. js代码去重](#js代码去重)\n- [3. 无阻塞下载脚本](#无阻塞下载脚本)\n- [4. 外联js和行内js](#外联js和行内js)\n- [5. js编码要点](#js编码要点)\n\n- [七. 图片相关优化](#七-图片相关优化)\n- [八. 其他优化](#八-其他优化)\n\n# 前端性能优化点\n\n> 说明：本文主要介绍前端性能优化点\n\n---\n\n## 一. HTTP优化\n\n### 1. 减少HTTP请求\n\n1. 合并文件，例如css代码和js代码分别合并到一个css文件和js文件中;\n2. 使用css sprite，详细请参考css优化中的css sprite部分。\n3. 使用base64技术\n\n### 2. 重定向优化\n\n1. 消除没必要的跳转\n2. 利用服务器重写用户键入的链接\n3. 使用HTTP而不是js或者meta来重定向\n\n### 3. 避免死链/空链/404/410错误\n\n1. 避免出现404 Not Found错误\n2. 避免出现图片请求空链接（img.src=””）\n\n### 4. 尽早flush buffer\n\n尽早的使用flush buffer可以让一部分内容先加载出来，提高用户体验。\n\n### 5. http中的character设置\n\n指定content-type和正确的character编码\n\n---\n\n## 二. 缓存优化\n\n### 1. 浏览器缓存\n\n#### 添加 Expires 或 Cache-Control 头\n\n1. 对于静态资源：通过设置一个很远的过期时间来实现“从不过期”\n2. \n对于动态资源：用一个适当的 Cache-Control 头来帮助浏览器控制请求\n\n浏览器利用缓存来减少http请求的数目和大小，让页面加载的更快。web服务器利用http响应中的Expires头来告诉客户端一个资源能够被缓存多久。\n\n需要注意的是，如果你利用了一个“不过期”的Expires头，你必须在资源改变的同时改变资源的名字。这一技术提高页面性能是基于用户已经访问过你的网站的基础之上的。\n\n3. \n设置Last-Modified日期为最近资源需要改变的时间。\n\n#### 对动态可用缓存使用“身份识别”\n\n通过链接到资源的唯一url（每次改变资源时同时改变其文件名）来改变缓存\n\n#### 为IE设置Vary的header\n\n#### 避免firefox中URL造成的缓存冲突\n\nfirefox通过hash表存储url的缓存，但hash值仅仅有8个字符，可能会造成hash冲突，所以你需要确保你的资源urldiff多于8字符边界。\n\n### 2. 代理服务器(静态资源服务器)缓存\n\n*利用Cache-control：public的头可以让资源缓存在一个web代理服务器上面来让其他用户使用。*\n\n1. \n不要在静态资源的url上面添加查询字符串\n\n2. \n不用在代理服务器上缓存设置了cookie的资源\n\n3. \n要有使用代理缓存js和css文件的意识\n\n---\n\n## 三. DNS\n\n### 1. 减小DNS解析\n\n1.固定URL提供资源\n2.尽可能的使用URL路径来代替主机域名，例如developer.example.com可以被www.example.com/developer代替。除非有技术上的原因需要不同的主机域名。\n3.将从同一主机域名下的需要先加载的js文件作为主要文件送达\n4.考虑使用DNS预解析\n\n### 2. 增加静态资源域名\n\n实现多个资源的并行下载\n\n---\n\n## 四. 服务器负载优化\n\n### 1. 使用CND\n\nCDN可以帮助用户更快的获取到所需要的资源。\n\n### 2. Cookie优化\n\n1.使用服务器端的存储为大多数的cookie来做有效载荷：在cookie里存key，在服务器端存value。\n2.移除没有用的或者重复的cookie\n3.静态资源请求中不要带上cookie\n4.不要将需要提前加载的js放到没有cookie的域中加载\n\n### 3. 使用Gzip\n\nGzip是当前最流行，最有效的压缩方式。\n\n1.在http/1.1中，web客户端明确支持在http请求中 Accept-Encoding 头 的 Accept-Encoding: gzip, deflate 压缩方式\n2.Gzip一般能减少服务器响应文件70%的大小，90%的浏览器都支持gzip\n3.服务器基于文件类型来选择gzip压缩，很多网站gzip他们的html文件，同样也可以gzip脚本和样式表\n4.事实上，任何的响应文本，包括xml和json都有压缩的价值，图片和pdf文件不应该被gizp，因为他们已经被压缩过了\n\n### 4. 压缩文件\n\n*压缩包括：Javascript、CSS、HTML*\n\n让你写的页面能够更有效的压缩：\n1.按照字母排序指定css键对值\n2.按照字母排序指定html属性\n3.对html属性使用一致的引号\n4.使用一致的字母（小写字母）\n5.移除没有用到的css\n\n---\n\n## 五. CSS相关优化\n\n### 1. 样式表合并放头部\n\n1.将样式表移到文件的Head可以让页面加载的更快，这是因为将样式表放在头部有利于页面渲染。\n2.将样式表放在底部的问题是它阻止了许多浏览器的渲染进度。这些浏览器会锁定渲染进程来保证页面上的元素在他们的样式改变时重绘。\n\n### 2. css编码要点\n\n具体参看性能相关编码规范中的css编码规范\n\n### 3. 使用css Sprite\n\n1.将图片水平放置在sprite中可以让文件大小更小。\n2.对一起加载的图片使用sprite\n3.GIF和PNG图片优先使用sprite\n4.小图片优先sprite\n5.可缓存的图片使用sprite\n6.使用sprite工具\n7.尽量减少sprite图片中的空白空间\n8.将色彩范围相近的图片进行sprite\n\n### 4. 外联css\n\n利用浏览器缓存，将一些公共的css进行外链，使用缓存，加快用户第一次以后访问页面的速度\n\n---\n\n## 六. Javascript相关优化\n\n### 1. js文件放底部\n\n这一问题的原因是脚本是并行阻塞下载的。HTTP/1.1协议中建议浏览器不在同一域名下并行下载多于两个的资源。假如你的图片是在多个域名下的，你可以并行下载超过两张的图片。可是一个脚本在下载的时候，浏览器不能再开始其他的下载，即使在不同的域名下。\n\n一个可供采纳的建议是利用延迟加载脚本技术（defer）。这是一种可以让浏览器继续渲染的方案。不幸的是，fireforx不支持defer属性。\n\n### 2. js代码去重\n\n1.将重复的js代码去掉\n2.将没有使用过的变量去掉\n3.将没有调用到的函数去掉\n\n### 3. 无阻塞下载脚本\n\n*几种下载外部脚本且不被阻塞的技术*\n\n1. XHR Eval：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过eval执行内容。缺陷：不能跨域。\n2. XHR 注入：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过创建script元素注入其中执行内容。缺陷：不能跨域。\n3. Script in Iframe：通过iframe的src属性加载脚本。\n4. Script DOM Element：通过创建script标签元素来加载脚本。\n5. Script Defer：IE特有\n6. document.write Script Tag：通过把script标签代码用write方法放到页面中加载脚本。\n\n### 4. 外联js和行内js\n\n1.将外联脚本放在外联样式表之后\n2.将行内脚本放在其他资源之后\n\n### 5. js编码要点\n\n详细请参看前端性能优化相关编码规范：js编码规范\n\n---\n\n## 七. 图片相关优化\n\n1. 图片压缩：在条件允许的情况下尽量使用PNG8格式\n2. 图片合并：详见CSS sprite\n3. 图片缩放：服务器端进行图片缩放\n\n## 八. 其他优化\n\n1. 减少页面DOM元素\n2. 延迟加载和预加载资源\n3. 将Get作为Ajax请求的方法\n4. 尽量不要使用iframe：\n\n---\n","source":"_posts/前端性能优化点-day05.md","raw":"---\ntitle:  前端性能优化点\ndate: 2018-08-02 12:35:30\ntags: \n    - 前端性能\ncategories: \n    - 大杂烩\n\n---\n\n### 目录导航\n\n- [前端性能优化点](#前端性能优化点)\n- [一. HTTP优化](#一-http优化)\n- [1. 减少HTTP请求](#减少http请求)\n- [2. 重定向优化](#重定向优化)\n- [3. 避免死链/空链/404/410错误](#避免死链空链错误)\n- [4. 尽早flush buffer](#尽早flush-buffer)\n- [5. http中的character设置](#http中的character设置)\n\n- [二. 缓存优化](#二-缓存优化)\n- [1. 浏览器缓存](#浏览器缓存)\n- [添加 Expires 或 Cache-Control 头](#添加-expires-或-cache-control-头)\n- [对动态可用缓存使用“身份识别”](#对动态可用缓存使用身份识别)\n- [为IE设置Vary的header](#为ie设置vary的header)\n- [避免firefox中URL造成的缓存冲突](#避免firefox中url造成的缓存冲突)\n\n- [2. 代理服务器(静态资源服务器)缓存](#代理服务器静态资源服务器缓存)\n\n- [三. DNS](#三-dns)\n- [1. 减小DNS解析](#减小dns解析)\n- [2. 增加静态资源域名](#增加静态资源域名)\n\n- [四. 服务器负载优化](#四-服务器负载优化)\n- [1. 使用CND](#使用cnd)\n- [2. Cookie优化](#cookie优化)\n- [3. 使用Gzip](#使用gzip)\n- [4. 压缩文件](#压缩文件)\n\n- [五. CSS相关优化](#五-css相关优化)\n- [1. 样式表合并放头部](#样式表合并放头部)\n- [2. css编码要点](#css编码要点)\n- [3. 使用css Sprite](#使用css-sprite)\n- [4. 外联css](#外联css)\n\n- [六. Javascript相关优化](#六-javascript相关优化)\n- [1. js文件放底部](#js文件放底部)\n- [2. js代码去重](#js代码去重)\n- [3. 无阻塞下载脚本](#无阻塞下载脚本)\n- [4. 外联js和行内js](#外联js和行内js)\n- [5. js编码要点](#js编码要点)\n\n- [七. 图片相关优化](#七-图片相关优化)\n- [八. 其他优化](#八-其他优化)\n\n# 前端性能优化点\n\n> 说明：本文主要介绍前端性能优化点\n\n---\n\n## 一. HTTP优化\n\n### 1. 减少HTTP请求\n\n1. 合并文件，例如css代码和js代码分别合并到一个css文件和js文件中;\n2. 使用css sprite，详细请参考css优化中的css sprite部分。\n3. 使用base64技术\n\n### 2. 重定向优化\n\n1. 消除没必要的跳转\n2. 利用服务器重写用户键入的链接\n3. 使用HTTP而不是js或者meta来重定向\n\n### 3. 避免死链/空链/404/410错误\n\n1. 避免出现404 Not Found错误\n2. 避免出现图片请求空链接（img.src=””）\n\n### 4. 尽早flush buffer\n\n尽早的使用flush buffer可以让一部分内容先加载出来，提高用户体验。\n\n### 5. http中的character设置\n\n指定content-type和正确的character编码\n\n---\n\n## 二. 缓存优化\n\n### 1. 浏览器缓存\n\n#### 添加 Expires 或 Cache-Control 头\n\n1. 对于静态资源：通过设置一个很远的过期时间来实现“从不过期”\n2. \n对于动态资源：用一个适当的 Cache-Control 头来帮助浏览器控制请求\n\n浏览器利用缓存来减少http请求的数目和大小，让页面加载的更快。web服务器利用http响应中的Expires头来告诉客户端一个资源能够被缓存多久。\n\n需要注意的是，如果你利用了一个“不过期”的Expires头，你必须在资源改变的同时改变资源的名字。这一技术提高页面性能是基于用户已经访问过你的网站的基础之上的。\n\n3. \n设置Last-Modified日期为最近资源需要改变的时间。\n\n#### 对动态可用缓存使用“身份识别”\n\n通过链接到资源的唯一url（每次改变资源时同时改变其文件名）来改变缓存\n\n#### 为IE设置Vary的header\n\n#### 避免firefox中URL造成的缓存冲突\n\nfirefox通过hash表存储url的缓存，但hash值仅仅有8个字符，可能会造成hash冲突，所以你需要确保你的资源urldiff多于8字符边界。\n\n### 2. 代理服务器(静态资源服务器)缓存\n\n*利用Cache-control：public的头可以让资源缓存在一个web代理服务器上面来让其他用户使用。*\n\n1. \n不要在静态资源的url上面添加查询字符串\n\n2. \n不用在代理服务器上缓存设置了cookie的资源\n\n3. \n要有使用代理缓存js和css文件的意识\n\n---\n\n## 三. DNS\n\n### 1. 减小DNS解析\n\n1.固定URL提供资源\n2.尽可能的使用URL路径来代替主机域名，例如developer.example.com可以被www.example.com/developer代替。除非有技术上的原因需要不同的主机域名。\n3.将从同一主机域名下的需要先加载的js文件作为主要文件送达\n4.考虑使用DNS预解析\n\n### 2. 增加静态资源域名\n\n实现多个资源的并行下载\n\n---\n\n## 四. 服务器负载优化\n\n### 1. 使用CND\n\nCDN可以帮助用户更快的获取到所需要的资源。\n\n### 2. Cookie优化\n\n1.使用服务器端的存储为大多数的cookie来做有效载荷：在cookie里存key，在服务器端存value。\n2.移除没有用的或者重复的cookie\n3.静态资源请求中不要带上cookie\n4.不要将需要提前加载的js放到没有cookie的域中加载\n\n### 3. 使用Gzip\n\nGzip是当前最流行，最有效的压缩方式。\n\n1.在http/1.1中，web客户端明确支持在http请求中 Accept-Encoding 头 的 Accept-Encoding: gzip, deflate 压缩方式\n2.Gzip一般能减少服务器响应文件70%的大小，90%的浏览器都支持gzip\n3.服务器基于文件类型来选择gzip压缩，很多网站gzip他们的html文件，同样也可以gzip脚本和样式表\n4.事实上，任何的响应文本，包括xml和json都有压缩的价值，图片和pdf文件不应该被gizp，因为他们已经被压缩过了\n\n### 4. 压缩文件\n\n*压缩包括：Javascript、CSS、HTML*\n\n让你写的页面能够更有效的压缩：\n1.按照字母排序指定css键对值\n2.按照字母排序指定html属性\n3.对html属性使用一致的引号\n4.使用一致的字母（小写字母）\n5.移除没有用到的css\n\n---\n\n## 五. CSS相关优化\n\n### 1. 样式表合并放头部\n\n1.将样式表移到文件的Head可以让页面加载的更快，这是因为将样式表放在头部有利于页面渲染。\n2.将样式表放在底部的问题是它阻止了许多浏览器的渲染进度。这些浏览器会锁定渲染进程来保证页面上的元素在他们的样式改变时重绘。\n\n### 2. css编码要点\n\n具体参看性能相关编码规范中的css编码规范\n\n### 3. 使用css Sprite\n\n1.将图片水平放置在sprite中可以让文件大小更小。\n2.对一起加载的图片使用sprite\n3.GIF和PNG图片优先使用sprite\n4.小图片优先sprite\n5.可缓存的图片使用sprite\n6.使用sprite工具\n7.尽量减少sprite图片中的空白空间\n8.将色彩范围相近的图片进行sprite\n\n### 4. 外联css\n\n利用浏览器缓存，将一些公共的css进行外链，使用缓存，加快用户第一次以后访问页面的速度\n\n---\n\n## 六. Javascript相关优化\n\n### 1. js文件放底部\n\n这一问题的原因是脚本是并行阻塞下载的。HTTP/1.1协议中建议浏览器不在同一域名下并行下载多于两个的资源。假如你的图片是在多个域名下的，你可以并行下载超过两张的图片。可是一个脚本在下载的时候，浏览器不能再开始其他的下载，即使在不同的域名下。\n\n一个可供采纳的建议是利用延迟加载脚本技术（defer）。这是一种可以让浏览器继续渲染的方案。不幸的是，fireforx不支持defer属性。\n\n### 2. js代码去重\n\n1.将重复的js代码去掉\n2.将没有使用过的变量去掉\n3.将没有调用到的函数去掉\n\n### 3. 无阻塞下载脚本\n\n*几种下载外部脚本且不被阻塞的技术*\n\n1. XHR Eval：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过eval执行内容。缺陷：不能跨域。\n2. XHR 注入：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过创建script元素注入其中执行内容。缺陷：不能跨域。\n3. Script in Iframe：通过iframe的src属性加载脚本。\n4. Script DOM Element：通过创建script标签元素来加载脚本。\n5. Script Defer：IE特有\n6. document.write Script Tag：通过把script标签代码用write方法放到页面中加载脚本。\n\n### 4. 外联js和行内js\n\n1.将外联脚本放在外联样式表之后\n2.将行内脚本放在其他资源之后\n\n### 5. js编码要点\n\n详细请参看前端性能优化相关编码规范：js编码规范\n\n---\n\n## 七. 图片相关优化\n\n1. 图片压缩：在条件允许的情况下尽量使用PNG8格式\n2. 图片合并：详见CSS sprite\n3. 图片缩放：服务器端进行图片缩放\n\n## 八. 其他优化\n\n1. 减少页面DOM元素\n2. 延迟加载和预加载资源\n3. 将Get作为Ajax请求的方法\n4. 尽量不要使用iframe：\n\n---\n","slug":"前端性能优化点-day05","published":1,"updated":"2019-04-23T09:49:20.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjutlylft0003zcum4gbmhi6w","content":"<h3 id=\"目录导航\"><a href=\"#目录导航\" class=\"headerlink\" title=\"目录导航\"></a>目录导航</h3><ul>\n<li><a href=\"#前端性能优化点\">前端性能优化点</a></li>\n<li><a href=\"#一-http优化\">一. HTTP优化</a></li>\n<li><a href=\"#减少http请求\">1. 减少HTTP请求</a></li>\n<li><a href=\"#重定向优化\">2. 重定向优化</a></li>\n<li><a href=\"#避免死链空链错误\">3. 避免死链/空链/404/410错误</a></li>\n<li><a href=\"#尽早flush-buffer\">4. 尽早flush buffer</a></li>\n<li><p><a href=\"#http中的character设置\">5. http中的character设置</a></p>\n</li>\n<li><p><a href=\"#二-缓存优化\">二. 缓存优化</a></p>\n</li>\n<li><a href=\"#浏览器缓存\">1. 浏览器缓存</a></li>\n<li><a href=\"#添加-expires-或-cache-control-头\">添加 Expires 或 Cache-Control 头</a></li>\n<li><a href=\"#对动态可用缓存使用身份识别\">对动态可用缓存使用“身份识别”</a></li>\n<li><a href=\"#为ie设置vary的header\">为IE设置Vary的header</a></li>\n<li><p><a href=\"#避免firefox中url造成的缓存冲突\">避免firefox中URL造成的缓存冲突</a></p>\n</li>\n<li><p><a href=\"#代理服务器静态资源服务器缓存\">2. 代理服务器(静态资源服务器)缓存</a></p>\n</li>\n<li><p><a href=\"#三-dns\">三. DNS</a></p>\n</li>\n<li><a href=\"#减小dns解析\">1. 减小DNS解析</a></li>\n<li><p><a href=\"#增加静态资源域名\">2. 增加静态资源域名</a></p>\n</li>\n<li><p><a href=\"#四-服务器负载优化\">四. 服务器负载优化</a></p>\n</li>\n<li><a href=\"#使用cnd\">1. 使用CND</a></li>\n<li><a href=\"#cookie优化\">2. Cookie优化</a></li>\n<li><a href=\"#使用gzip\">3. 使用Gzip</a></li>\n<li><p><a href=\"#压缩文件\">4. 压缩文件</a></p>\n</li>\n<li><p><a href=\"#五-css相关优化\">五. CSS相关优化</a></p>\n</li>\n<li><a href=\"#样式表合并放头部\">1. 样式表合并放头部</a></li>\n<li><a href=\"#css编码要点\">2. css编码要点</a></li>\n<li><a href=\"#使用css-sprite\">3. 使用css Sprite</a></li>\n<li><p><a href=\"#外联css\">4. 外联css</a></p>\n</li>\n<li><p><a href=\"#六-javascript相关优化\">六. Javascript相关优化</a></p>\n</li>\n<li><a href=\"#js文件放底部\">1. js文件放底部</a></li>\n<li><a href=\"#js代码去重\">2. js代码去重</a></li>\n<li><a href=\"#无阻塞下载脚本\">3. 无阻塞下载脚本</a></li>\n<li><a href=\"#外联js和行内js\">4. 外联js和行内js</a></li>\n<li><p><a href=\"#js编码要点\">5. js编码要点</a></p>\n</li>\n<li><p><a href=\"#七-图片相关优化\">七. 图片相关优化</a></p>\n</li>\n<li><a href=\"#八-其他优化\">八. 其他优化</a></li>\n</ul>\n<h1 id=\"前端性能优化点\"><a href=\"#前端性能优化点\" class=\"headerlink\" title=\"前端性能优化点\"></a>前端性能优化点</h1><blockquote>\n<p>说明：本文主要介绍前端性能优化点</p>\n</blockquote>\n<hr>\n<h2 id=\"一-HTTP优化\"><a href=\"#一-HTTP优化\" class=\"headerlink\" title=\"一. HTTP优化\"></a>一. HTTP优化</h2><h3 id=\"1-减少HTTP请求\"><a href=\"#1-减少HTTP请求\" class=\"headerlink\" title=\"1. 减少HTTP请求\"></a>1. 减少HTTP请求</h3><ol>\n<li>合并文件，例如css代码和js代码分别合并到一个css文件和js文件中;</li>\n<li>使用css sprite，详细请参考css优化中的css sprite部分。</li>\n<li>使用base64技术</li>\n</ol>\n<h3 id=\"2-重定向优化\"><a href=\"#2-重定向优化\" class=\"headerlink\" title=\"2. 重定向优化\"></a>2. 重定向优化</h3><ol>\n<li>消除没必要的跳转</li>\n<li>利用服务器重写用户键入的链接</li>\n<li>使用HTTP而不是js或者meta来重定向</li>\n</ol>\n<h3 id=\"3-避免死链-空链-404-410错误\"><a href=\"#3-避免死链-空链-404-410错误\" class=\"headerlink\" title=\"3. 避免死链/空链/404/410错误\"></a>3. 避免死链/空链/404/410错误</h3><ol>\n<li>避免出现404 Not Found错误</li>\n<li>避免出现图片请求空链接（img.src=””）</li>\n</ol>\n<h3 id=\"4-尽早flush-buffer\"><a href=\"#4-尽早flush-buffer\" class=\"headerlink\" title=\"4. 尽早flush buffer\"></a>4. 尽早flush buffer</h3><p>尽早的使用flush buffer可以让一部分内容先加载出来，提高用户体验。</p>\n<h3 id=\"5-http中的character设置\"><a href=\"#5-http中的character设置\" class=\"headerlink\" title=\"5. http中的character设置\"></a>5. http中的character设置</h3><p>指定content-type和正确的character编码</p>\n<hr>\n<h2 id=\"二-缓存优化\"><a href=\"#二-缓存优化\" class=\"headerlink\" title=\"二. 缓存优化\"></a>二. 缓存优化</h2><h3 id=\"1-浏览器缓存\"><a href=\"#1-浏览器缓存\" class=\"headerlink\" title=\"1. 浏览器缓存\"></a>1. 浏览器缓存</h3><h4 id=\"添加-Expires-或-Cache-Control-头\"><a href=\"#添加-Expires-或-Cache-Control-头\" class=\"headerlink\" title=\"添加 Expires 或 Cache-Control 头\"></a>添加 Expires 或 Cache-Control 头</h4><ol>\n<li>对于静态资源：通过设置一个很远的过期时间来实现“从不过期”</li>\n<li>对于动态资源：用一个适当的 Cache-Control 头来帮助浏览器控制请求</li>\n</ol>\n<p>浏览器利用缓存来减少http请求的数目和大小，让页面加载的更快。web服务器利用http响应中的Expires头来告诉客户端一个资源能够被缓存多久。</p>\n<p>需要注意的是，如果你利用了一个“不过期”的Expires头，你必须在资源改变的同时改变资源的名字。这一技术提高页面性能是基于用户已经访问过你的网站的基础之上的。</p>\n<ol start=\"3\">\n<li>设置Last-Modified日期为最近资源需要改变的时间。</li>\n</ol>\n<h4 id=\"对动态可用缓存使用“身份识别”\"><a href=\"#对动态可用缓存使用“身份识别”\" class=\"headerlink\" title=\"对动态可用缓存使用“身份识别”\"></a>对动态可用缓存使用“身份识别”</h4><p>通过链接到资源的唯一url（每次改变资源时同时改变其文件名）来改变缓存</p>\n<h4 id=\"为IE设置Vary的header\"><a href=\"#为IE设置Vary的header\" class=\"headerlink\" title=\"为IE设置Vary的header\"></a>为IE设置Vary的header</h4><h4 id=\"避免firefox中URL造成的缓存冲突\"><a href=\"#避免firefox中URL造成的缓存冲突\" class=\"headerlink\" title=\"避免firefox中URL造成的缓存冲突\"></a>避免firefox中URL造成的缓存冲突</h4><p>firefox通过hash表存储url的缓存，但hash值仅仅有8个字符，可能会造成hash冲突，所以你需要确保你的资源urldiff多于8字符边界。</p>\n<h3 id=\"2-代理服务器-静态资源服务器-缓存\"><a href=\"#2-代理服务器-静态资源服务器-缓存\" class=\"headerlink\" title=\"2. 代理服务器(静态资源服务器)缓存\"></a>2. 代理服务器(静态资源服务器)缓存</h3><p><em>利用Cache-control：public的头可以让资源缓存在一个web代理服务器上面来让其他用户使用。</em></p>\n<ol>\n<li><p>不要在静态资源的url上面添加查询字符串</p>\n</li>\n<li><p>不用在代理服务器上缓存设置了cookie的资源</p>\n</li>\n<li><p>要有使用代理缓存js和css文件的意识</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"三-DNS\"><a href=\"#三-DNS\" class=\"headerlink\" title=\"三. DNS\"></a>三. DNS</h2><h3 id=\"1-减小DNS解析\"><a href=\"#1-减小DNS解析\" class=\"headerlink\" title=\"1. 减小DNS解析\"></a>1. 减小DNS解析</h3><p>1.固定URL提供资源<br>2.尽可能的使用URL路径来代替主机域名，例如developer.example.com可以被<a href=\"http://www.example.com/developer代替。除非有技术上的原因需要不同的主机域名。\" target=\"_blank\" rel=\"noopener\">www.example.com/developer代替。除非有技术上的原因需要不同的主机域名。</a><br>3.将从同一主机域名下的需要先加载的js文件作为主要文件送达<br>4.考虑使用DNS预解析</p>\n<h3 id=\"2-增加静态资源域名\"><a href=\"#2-增加静态资源域名\" class=\"headerlink\" title=\"2. 增加静态资源域名\"></a>2. 增加静态资源域名</h3><p>实现多个资源的并行下载</p>\n<hr>\n<h2 id=\"四-服务器负载优化\"><a href=\"#四-服务器负载优化\" class=\"headerlink\" title=\"四. 服务器负载优化\"></a>四. 服务器负载优化</h2><h3 id=\"1-使用CND\"><a href=\"#1-使用CND\" class=\"headerlink\" title=\"1. 使用CND\"></a>1. 使用CND</h3><p>CDN可以帮助用户更快的获取到所需要的资源。</p>\n<h3 id=\"2-Cookie优化\"><a href=\"#2-Cookie优化\" class=\"headerlink\" title=\"2. Cookie优化\"></a>2. Cookie优化</h3><p>1.使用服务器端的存储为大多数的cookie来做有效载荷：在cookie里存key，在服务器端存value。<br>2.移除没有用的或者重复的cookie<br>3.静态资源请求中不要带上cookie<br>4.不要将需要提前加载的js放到没有cookie的域中加载</p>\n<h3 id=\"3-使用Gzip\"><a href=\"#3-使用Gzip\" class=\"headerlink\" title=\"3. 使用Gzip\"></a>3. 使用Gzip</h3><p>Gzip是当前最流行，最有效的压缩方式。</p>\n<p>1.在http/1.1中，web客户端明确支持在http请求中 Accept-Encoding 头 的 Accept-Encoding: gzip, deflate 压缩方式<br>2.Gzip一般能减少服务器响应文件70%的大小，90%的浏览器都支持gzip<br>3.服务器基于文件类型来选择gzip压缩，很多网站gzip他们的html文件，同样也可以gzip脚本和样式表<br>4.事实上，任何的响应文本，包括xml和json都有压缩的价值，图片和pdf文件不应该被gizp，因为他们已经被压缩过了</p>\n<h3 id=\"4-压缩文件\"><a href=\"#4-压缩文件\" class=\"headerlink\" title=\"4. 压缩文件\"></a>4. 压缩文件</h3><p><em>压缩包括：Javascript、CSS、HTML</em></p>\n<p>让你写的页面能够更有效的压缩：<br>1.按照字母排序指定css键对值<br>2.按照字母排序指定html属性<br>3.对html属性使用一致的引号<br>4.使用一致的字母（小写字母）<br>5.移除没有用到的css</p>\n<hr>\n<h2 id=\"五-CSS相关优化\"><a href=\"#五-CSS相关优化\" class=\"headerlink\" title=\"五. CSS相关优化\"></a>五. CSS相关优化</h2><h3 id=\"1-样式表合并放头部\"><a href=\"#1-样式表合并放头部\" class=\"headerlink\" title=\"1. 样式表合并放头部\"></a>1. 样式表合并放头部</h3><p>1.将样式表移到文件的Head可以让页面加载的更快，这是因为将样式表放在头部有利于页面渲染。<br>2.将样式表放在底部的问题是它阻止了许多浏览器的渲染进度。这些浏览器会锁定渲染进程来保证页面上的元素在他们的样式改变时重绘。</p>\n<h3 id=\"2-css编码要点\"><a href=\"#2-css编码要点\" class=\"headerlink\" title=\"2. css编码要点\"></a>2. css编码要点</h3><p>具体参看性能相关编码规范中的css编码规范</p>\n<h3 id=\"3-使用css-Sprite\"><a href=\"#3-使用css-Sprite\" class=\"headerlink\" title=\"3. 使用css Sprite\"></a>3. 使用css Sprite</h3><p>1.将图片水平放置在sprite中可以让文件大小更小。<br>2.对一起加载的图片使用sprite<br>3.GIF和PNG图片优先使用sprite<br>4.小图片优先sprite<br>5.可缓存的图片使用sprite<br>6.使用sprite工具<br>7.尽量减少sprite图片中的空白空间<br>8.将色彩范围相近的图片进行sprite</p>\n<h3 id=\"4-外联css\"><a href=\"#4-外联css\" class=\"headerlink\" title=\"4. 外联css\"></a>4. 外联css</h3><p>利用浏览器缓存，将一些公共的css进行外链，使用缓存，加快用户第一次以后访问页面的速度</p>\n<hr>\n<h2 id=\"六-Javascript相关优化\"><a href=\"#六-Javascript相关优化\" class=\"headerlink\" title=\"六. Javascript相关优化\"></a>六. Javascript相关优化</h2><h3 id=\"1-js文件放底部\"><a href=\"#1-js文件放底部\" class=\"headerlink\" title=\"1. js文件放底部\"></a>1. js文件放底部</h3><p>这一问题的原因是脚本是并行阻塞下载的。HTTP/1.1协议中建议浏览器不在同一域名下并行下载多于两个的资源。假如你的图片是在多个域名下的，你可以并行下载超过两张的图片。可是一个脚本在下载的时候，浏览器不能再开始其他的下载，即使在不同的域名下。</p>\n<p>一个可供采纳的建议是利用延迟加载脚本技术（defer）。这是一种可以让浏览器继续渲染的方案。不幸的是，fireforx不支持defer属性。</p>\n<h3 id=\"2-js代码去重\"><a href=\"#2-js代码去重\" class=\"headerlink\" title=\"2. js代码去重\"></a>2. js代码去重</h3><p>1.将重复的js代码去掉<br>2.将没有使用过的变量去掉<br>3.将没有调用到的函数去掉</p>\n<h3 id=\"3-无阻塞下载脚本\"><a href=\"#3-无阻塞下载脚本\" class=\"headerlink\" title=\"3. 无阻塞下载脚本\"></a>3. 无阻塞下载脚本</h3><p><em>几种下载外部脚本且不被阻塞的技术</em></p>\n<ol>\n<li>XHR Eval：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过eval执行内容。缺陷：不能跨域。</li>\n<li>XHR 注入：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过创建script元素注入其中执行内容。缺陷：不能跨域。</li>\n<li>Script in Iframe：通过iframe的src属性加载脚本。</li>\n<li>Script DOM Element：通过创建script标签元素来加载脚本。</li>\n<li>Script Defer：IE特有</li>\n<li>document.write Script Tag：通过把script标签代码用write方法放到页面中加载脚本。</li>\n</ol>\n<h3 id=\"4-外联js和行内js\"><a href=\"#4-外联js和行内js\" class=\"headerlink\" title=\"4. 外联js和行内js\"></a>4. 外联js和行内js</h3><p>1.将外联脚本放在外联样式表之后<br>2.将行内脚本放在其他资源之后</p>\n<h3 id=\"5-js编码要点\"><a href=\"#5-js编码要点\" class=\"headerlink\" title=\"5. js编码要点\"></a>5. js编码要点</h3><p>详细请参看前端性能优化相关编码规范：js编码规范</p>\n<hr>\n<h2 id=\"七-图片相关优化\"><a href=\"#七-图片相关优化\" class=\"headerlink\" title=\"七. 图片相关优化\"></a>七. 图片相关优化</h2><ol>\n<li>图片压缩：在条件允许的情况下尽量使用PNG8格式</li>\n<li>图片合并：详见CSS sprite</li>\n<li>图片缩放：服务器端进行图片缩放</li>\n</ol>\n<h2 id=\"八-其他优化\"><a href=\"#八-其他优化\" class=\"headerlink\" title=\"八. 其他优化\"></a>八. 其他优化</h2><ol>\n<li>减少页面DOM元素</li>\n<li>延迟加载和预加载资源</li>\n<li>将Get作为Ajax请求的方法</li>\n<li>尽量不要使用iframe：</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"目录导航\"><a href=\"#目录导航\" class=\"headerlink\" title=\"目录导航\"></a>目录导航</h3><ul>\n<li><a href=\"#前端性能优化点\">前端性能优化点</a></li>\n<li><a href=\"#一-http优化\">一. HTTP优化</a></li>\n<li><a href=\"#减少http请求\">1. 减少HTTP请求</a></li>\n<li><a href=\"#重定向优化\">2. 重定向优化</a></li>\n<li><a href=\"#避免死链空链错误\">3. 避免死链/空链/404/410错误</a></li>\n<li><a href=\"#尽早flush-buffer\">4. 尽早flush buffer</a></li>\n<li><p><a href=\"#http中的character设置\">5. http中的character设置</a></p>\n</li>\n<li><p><a href=\"#二-缓存优化\">二. 缓存优化</a></p>\n</li>\n<li><a href=\"#浏览器缓存\">1. 浏览器缓存</a></li>\n<li><a href=\"#添加-expires-或-cache-control-头\">添加 Expires 或 Cache-Control 头</a></li>\n<li><a href=\"#对动态可用缓存使用身份识别\">对动态可用缓存使用“身份识别”</a></li>\n<li><a href=\"#为ie设置vary的header\">为IE设置Vary的header</a></li>\n<li><p><a href=\"#避免firefox中url造成的缓存冲突\">避免firefox中URL造成的缓存冲突</a></p>\n</li>\n<li><p><a href=\"#代理服务器静态资源服务器缓存\">2. 代理服务器(静态资源服务器)缓存</a></p>\n</li>\n<li><p><a href=\"#三-dns\">三. DNS</a></p>\n</li>\n<li><a href=\"#减小dns解析\">1. 减小DNS解析</a></li>\n<li><p><a href=\"#增加静态资源域名\">2. 增加静态资源域名</a></p>\n</li>\n<li><p><a href=\"#四-服务器负载优化\">四. 服务器负载优化</a></p>\n</li>\n<li><a href=\"#使用cnd\">1. 使用CND</a></li>\n<li><a href=\"#cookie优化\">2. Cookie优化</a></li>\n<li><a href=\"#使用gzip\">3. 使用Gzip</a></li>\n<li><p><a href=\"#压缩文件\">4. 压缩文件</a></p>\n</li>\n<li><p><a href=\"#五-css相关优化\">五. CSS相关优化</a></p>\n</li>\n<li><a href=\"#样式表合并放头部\">1. 样式表合并放头部</a></li>\n<li><a href=\"#css编码要点\">2. css编码要点</a></li>\n<li><a href=\"#使用css-sprite\">3. 使用css Sprite</a></li>\n<li><p><a href=\"#外联css\">4. 外联css</a></p>\n</li>\n<li><p><a href=\"#六-javascript相关优化\">六. Javascript相关优化</a></p>\n</li>\n<li><a href=\"#js文件放底部\">1. js文件放底部</a></li>\n<li><a href=\"#js代码去重\">2. js代码去重</a></li>\n<li><a href=\"#无阻塞下载脚本\">3. 无阻塞下载脚本</a></li>\n<li><a href=\"#外联js和行内js\">4. 外联js和行内js</a></li>\n<li><p><a href=\"#js编码要点\">5. js编码要点</a></p>\n</li>\n<li><p><a href=\"#七-图片相关优化\">七. 图片相关优化</a></p>\n</li>\n<li><a href=\"#八-其他优化\">八. 其他优化</a></li>\n</ul>\n<h1 id=\"前端性能优化点\"><a href=\"#前端性能优化点\" class=\"headerlink\" title=\"前端性能优化点\"></a>前端性能优化点</h1><blockquote>\n<p>说明：本文主要介绍前端性能优化点</p>\n</blockquote>\n<hr>\n<h2 id=\"一-HTTP优化\"><a href=\"#一-HTTP优化\" class=\"headerlink\" title=\"一. HTTP优化\"></a>一. HTTP优化</h2><h3 id=\"1-减少HTTP请求\"><a href=\"#1-减少HTTP请求\" class=\"headerlink\" title=\"1. 减少HTTP请求\"></a>1. 减少HTTP请求</h3><ol>\n<li>合并文件，例如css代码和js代码分别合并到一个css文件和js文件中;</li>\n<li>使用css sprite，详细请参考css优化中的css sprite部分。</li>\n<li>使用base64技术</li>\n</ol>\n<h3 id=\"2-重定向优化\"><a href=\"#2-重定向优化\" class=\"headerlink\" title=\"2. 重定向优化\"></a>2. 重定向优化</h3><ol>\n<li>消除没必要的跳转</li>\n<li>利用服务器重写用户键入的链接</li>\n<li>使用HTTP而不是js或者meta来重定向</li>\n</ol>\n<h3 id=\"3-避免死链-空链-404-410错误\"><a href=\"#3-避免死链-空链-404-410错误\" class=\"headerlink\" title=\"3. 避免死链/空链/404/410错误\"></a>3. 避免死链/空链/404/410错误</h3><ol>\n<li>避免出现404 Not Found错误</li>\n<li>避免出现图片请求空链接（img.src=””）</li>\n</ol>\n<h3 id=\"4-尽早flush-buffer\"><a href=\"#4-尽早flush-buffer\" class=\"headerlink\" title=\"4. 尽早flush buffer\"></a>4. 尽早flush buffer</h3><p>尽早的使用flush buffer可以让一部分内容先加载出来，提高用户体验。</p>\n<h3 id=\"5-http中的character设置\"><a href=\"#5-http中的character设置\" class=\"headerlink\" title=\"5. http中的character设置\"></a>5. http中的character设置</h3><p>指定content-type和正确的character编码</p>\n<hr>\n<h2 id=\"二-缓存优化\"><a href=\"#二-缓存优化\" class=\"headerlink\" title=\"二. 缓存优化\"></a>二. 缓存优化</h2><h3 id=\"1-浏览器缓存\"><a href=\"#1-浏览器缓存\" class=\"headerlink\" title=\"1. 浏览器缓存\"></a>1. 浏览器缓存</h3><h4 id=\"添加-Expires-或-Cache-Control-头\"><a href=\"#添加-Expires-或-Cache-Control-头\" class=\"headerlink\" title=\"添加 Expires 或 Cache-Control 头\"></a>添加 Expires 或 Cache-Control 头</h4><ol>\n<li>对于静态资源：通过设置一个很远的过期时间来实现“从不过期”</li>\n<li>对于动态资源：用一个适当的 Cache-Control 头来帮助浏览器控制请求</li>\n</ol>\n<p>浏览器利用缓存来减少http请求的数目和大小，让页面加载的更快。web服务器利用http响应中的Expires头来告诉客户端一个资源能够被缓存多久。</p>\n<p>需要注意的是，如果你利用了一个“不过期”的Expires头，你必须在资源改变的同时改变资源的名字。这一技术提高页面性能是基于用户已经访问过你的网站的基础之上的。</p>\n<ol start=\"3\">\n<li>设置Last-Modified日期为最近资源需要改变的时间。</li>\n</ol>\n<h4 id=\"对动态可用缓存使用“身份识别”\"><a href=\"#对动态可用缓存使用“身份识别”\" class=\"headerlink\" title=\"对动态可用缓存使用“身份识别”\"></a>对动态可用缓存使用“身份识别”</h4><p>通过链接到资源的唯一url（每次改变资源时同时改变其文件名）来改变缓存</p>\n<h4 id=\"为IE设置Vary的header\"><a href=\"#为IE设置Vary的header\" class=\"headerlink\" title=\"为IE设置Vary的header\"></a>为IE设置Vary的header</h4><h4 id=\"避免firefox中URL造成的缓存冲突\"><a href=\"#避免firefox中URL造成的缓存冲突\" class=\"headerlink\" title=\"避免firefox中URL造成的缓存冲突\"></a>避免firefox中URL造成的缓存冲突</h4><p>firefox通过hash表存储url的缓存，但hash值仅仅有8个字符，可能会造成hash冲突，所以你需要确保你的资源urldiff多于8字符边界。</p>\n<h3 id=\"2-代理服务器-静态资源服务器-缓存\"><a href=\"#2-代理服务器-静态资源服务器-缓存\" class=\"headerlink\" title=\"2. 代理服务器(静态资源服务器)缓存\"></a>2. 代理服务器(静态资源服务器)缓存</h3><p><em>利用Cache-control：public的头可以让资源缓存在一个web代理服务器上面来让其他用户使用。</em></p>\n<ol>\n<li><p>不要在静态资源的url上面添加查询字符串</p>\n</li>\n<li><p>不用在代理服务器上缓存设置了cookie的资源</p>\n</li>\n<li><p>要有使用代理缓存js和css文件的意识</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"三-DNS\"><a href=\"#三-DNS\" class=\"headerlink\" title=\"三. DNS\"></a>三. DNS</h2><h3 id=\"1-减小DNS解析\"><a href=\"#1-减小DNS解析\" class=\"headerlink\" title=\"1. 减小DNS解析\"></a>1. 减小DNS解析</h3><p>1.固定URL提供资源<br>2.尽可能的使用URL路径来代替主机域名，例如developer.example.com可以被<a href=\"http://www.example.com/developer代替。除非有技术上的原因需要不同的主机域名。\" target=\"_blank\" rel=\"noopener\">www.example.com/developer代替。除非有技术上的原因需要不同的主机域名。</a><br>3.将从同一主机域名下的需要先加载的js文件作为主要文件送达<br>4.考虑使用DNS预解析</p>\n<h3 id=\"2-增加静态资源域名\"><a href=\"#2-增加静态资源域名\" class=\"headerlink\" title=\"2. 增加静态资源域名\"></a>2. 增加静态资源域名</h3><p>实现多个资源的并行下载</p>\n<hr>\n<h2 id=\"四-服务器负载优化\"><a href=\"#四-服务器负载优化\" class=\"headerlink\" title=\"四. 服务器负载优化\"></a>四. 服务器负载优化</h2><h3 id=\"1-使用CND\"><a href=\"#1-使用CND\" class=\"headerlink\" title=\"1. 使用CND\"></a>1. 使用CND</h3><p>CDN可以帮助用户更快的获取到所需要的资源。</p>\n<h3 id=\"2-Cookie优化\"><a href=\"#2-Cookie优化\" class=\"headerlink\" title=\"2. Cookie优化\"></a>2. Cookie优化</h3><p>1.使用服务器端的存储为大多数的cookie来做有效载荷：在cookie里存key，在服务器端存value。<br>2.移除没有用的或者重复的cookie<br>3.静态资源请求中不要带上cookie<br>4.不要将需要提前加载的js放到没有cookie的域中加载</p>\n<h3 id=\"3-使用Gzip\"><a href=\"#3-使用Gzip\" class=\"headerlink\" title=\"3. 使用Gzip\"></a>3. 使用Gzip</h3><p>Gzip是当前最流行，最有效的压缩方式。</p>\n<p>1.在http/1.1中，web客户端明确支持在http请求中 Accept-Encoding 头 的 Accept-Encoding: gzip, deflate 压缩方式<br>2.Gzip一般能减少服务器响应文件70%的大小，90%的浏览器都支持gzip<br>3.服务器基于文件类型来选择gzip压缩，很多网站gzip他们的html文件，同样也可以gzip脚本和样式表<br>4.事实上，任何的响应文本，包括xml和json都有压缩的价值，图片和pdf文件不应该被gizp，因为他们已经被压缩过了</p>\n<h3 id=\"4-压缩文件\"><a href=\"#4-压缩文件\" class=\"headerlink\" title=\"4. 压缩文件\"></a>4. 压缩文件</h3><p><em>压缩包括：Javascript、CSS、HTML</em></p>\n<p>让你写的页面能够更有效的压缩：<br>1.按照字母排序指定css键对值<br>2.按照字母排序指定html属性<br>3.对html属性使用一致的引号<br>4.使用一致的字母（小写字母）<br>5.移除没有用到的css</p>\n<hr>\n<h2 id=\"五-CSS相关优化\"><a href=\"#五-CSS相关优化\" class=\"headerlink\" title=\"五. CSS相关优化\"></a>五. CSS相关优化</h2><h3 id=\"1-样式表合并放头部\"><a href=\"#1-样式表合并放头部\" class=\"headerlink\" title=\"1. 样式表合并放头部\"></a>1. 样式表合并放头部</h3><p>1.将样式表移到文件的Head可以让页面加载的更快，这是因为将样式表放在头部有利于页面渲染。<br>2.将样式表放在底部的问题是它阻止了许多浏览器的渲染进度。这些浏览器会锁定渲染进程来保证页面上的元素在他们的样式改变时重绘。</p>\n<h3 id=\"2-css编码要点\"><a href=\"#2-css编码要点\" class=\"headerlink\" title=\"2. css编码要点\"></a>2. css编码要点</h3><p>具体参看性能相关编码规范中的css编码规范</p>\n<h3 id=\"3-使用css-Sprite\"><a href=\"#3-使用css-Sprite\" class=\"headerlink\" title=\"3. 使用css Sprite\"></a>3. 使用css Sprite</h3><p>1.将图片水平放置在sprite中可以让文件大小更小。<br>2.对一起加载的图片使用sprite<br>3.GIF和PNG图片优先使用sprite<br>4.小图片优先sprite<br>5.可缓存的图片使用sprite<br>6.使用sprite工具<br>7.尽量减少sprite图片中的空白空间<br>8.将色彩范围相近的图片进行sprite</p>\n<h3 id=\"4-外联css\"><a href=\"#4-外联css\" class=\"headerlink\" title=\"4. 外联css\"></a>4. 外联css</h3><p>利用浏览器缓存，将一些公共的css进行外链，使用缓存，加快用户第一次以后访问页面的速度</p>\n<hr>\n<h2 id=\"六-Javascript相关优化\"><a href=\"#六-Javascript相关优化\" class=\"headerlink\" title=\"六. Javascript相关优化\"></a>六. Javascript相关优化</h2><h3 id=\"1-js文件放底部\"><a href=\"#1-js文件放底部\" class=\"headerlink\" title=\"1. js文件放底部\"></a>1. js文件放底部</h3><p>这一问题的原因是脚本是并行阻塞下载的。HTTP/1.1协议中建议浏览器不在同一域名下并行下载多于两个的资源。假如你的图片是在多个域名下的，你可以并行下载超过两张的图片。可是一个脚本在下载的时候，浏览器不能再开始其他的下载，即使在不同的域名下。</p>\n<p>一个可供采纳的建议是利用延迟加载脚本技术（defer）。这是一种可以让浏览器继续渲染的方案。不幸的是，fireforx不支持defer属性。</p>\n<h3 id=\"2-js代码去重\"><a href=\"#2-js代码去重\" class=\"headerlink\" title=\"2. js代码去重\"></a>2. js代码去重</h3><p>1.将重复的js代码去掉<br>2.将没有使用过的变量去掉<br>3.将没有调用到的函数去掉</p>\n<h3 id=\"3-无阻塞下载脚本\"><a href=\"#3-无阻塞下载脚本\" class=\"headerlink\" title=\"3. 无阻塞下载脚本\"></a>3. 无阻塞下载脚本</h3><p><em>几种下载外部脚本且不被阻塞的技术</em></p>\n<ol>\n<li>XHR Eval：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过eval执行内容。缺陷：不能跨域。</li>\n<li>XHR 注入：通过XMLHttpRequest从服务器端获取脚本，响应完成时通过创建script元素注入其中执行内容。缺陷：不能跨域。</li>\n<li>Script in Iframe：通过iframe的src属性加载脚本。</li>\n<li>Script DOM Element：通过创建script标签元素来加载脚本。</li>\n<li>Script Defer：IE特有</li>\n<li>document.write Script Tag：通过把script标签代码用write方法放到页面中加载脚本。</li>\n</ol>\n<h3 id=\"4-外联js和行内js\"><a href=\"#4-外联js和行内js\" class=\"headerlink\" title=\"4. 外联js和行内js\"></a>4. 外联js和行内js</h3><p>1.将外联脚本放在外联样式表之后<br>2.将行内脚本放在其他资源之后</p>\n<h3 id=\"5-js编码要点\"><a href=\"#5-js编码要点\" class=\"headerlink\" title=\"5. js编码要点\"></a>5. js编码要点</h3><p>详细请参看前端性能优化相关编码规范：js编码规范</p>\n<hr>\n<h2 id=\"七-图片相关优化\"><a href=\"#七-图片相关优化\" class=\"headerlink\" title=\"七. 图片相关优化\"></a>七. 图片相关优化</h2><ol>\n<li>图片压缩：在条件允许的情况下尽量使用PNG8格式</li>\n<li>图片合并：详见CSS sprite</li>\n<li>图片缩放：服务器端进行图片缩放</li>\n</ol>\n<h2 id=\"八-其他优化\"><a href=\"#八-其他优化\" class=\"headerlink\" title=\"八. 其他优化\"></a>八. 其他优化</h2><ol>\n<li>减少页面DOM元素</li>\n<li>延迟加载和预加载资源</li>\n<li>将Get作为Ajax请求的方法</li>\n<li>尽量不要使用iframe：</li>\n</ol>\n<hr>\n"},{"title":"前端性能优化相关编码规范","date":"2018-06-22T06:14:20.000Z","cover":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556021941506&di=73676e7ba2dd679207b0dd74b905b3e2&imgtype=0&src=http%3A%2F%2Fwww.33lc.com%2Farticle%2FUploadPic%2F2012-10%2F2012101516255476188.jpg","_content":"\n### 目录导航\n\n- [前端性能优化相关编码规范](#前端性能优化相关编码规范)\n- [一. css编码规范](#一-css编码规范)\n- [1.避免使用css表达式](#避免使用css表达式)\n- [2.选择使用而不是@import](#选择使用而不是import)\n- [3.避免使用Filter](#避免使用filter)\n- [4.css选择符](#css选择符)\n- [css选择符类型](#css选择符类型)\n- [高效的使用css选择符](#高效的使用css选择符)\n- [编写高效的css选择符](#编写高效的css选择符)\n\n- [二. Javascript编码规范](#二-javascript编码规范)\n- [1. 一些导致js性能缓慢的例子](#一些导致js性能缓慢的例子)\n- [2. js陷阱](#js陷阱)\n- [3. 加载性能一些可以提高的点：](#加载性能一些可以提高的点)\n- [4. 鲜为人知的DOM](#鲜为人知的dom)\n- [dom性能缓慢可以归结为一下3个原因：](#dom性能缓慢可以归结为一下个原因)\n- [解决方案](#解决方案)\n\n- [5. 面向对象的Javascript](#面向对象的javascript)\n- [6. client-server对话](#client-server对话)\n- [7. 动画](#动画)\n- [8. 事件](#事件)\n- [9. 样式](#样式)\n\n# 前端性能优化相关编码规范\n\n> 说明：本文主要介绍在使用HTML、CSS、JS的过程中，需要注意的编码细节和规范\n\n---\n\n## 一. css编码规范\n\n### 1.避免使用css表达式\n\n### 2.选择使用而不是@import\n\n在IE中，使用@import相当于将放在页面底部。\n\n### 3.避免使用Filter\n\n使用filter的问题是它会阻塞渲染并且当浏览在加载图片时，会冻结浏览器。它也会提升内存消耗，它是作用于一个元素而不是一个图片，所以问题会更严重。\n\n最好的解决方案是完全避免使用AlphaImageLoader，用PNG8来代替。\n\n### 4.css选择符\n\ncss选择符的编写方式决定了浏览器必须执行的匹配次数，而某些类型的css选择符将会导致浏览器尝试更多匹配，因此开销比简单选择符更高。\n\n#### **css选择符类型**\n\nID选择符：这种类型的选择符简单且高效，用于匹配页面唯一的元素。#id {}\n\n类选择符.className {}\n\n类型选择符tagName {}\n\n相邻兄弟选择符H1 + #toc {}\n\n子选择符#toc > li {}\n\n后代选择符#toc A {}\n\n通配选择符 * {}\n\n属性选择符 [href=”#index”] {}\n\n伪类和伪元素 A:hover {}\n\n#### **高效的使用css选择符**\n\n*最右边优先：事实上，css选择符是从右到左进行匹配的。*\n\n##### 编写高效的css选择符\n\n1. 避免使用通配规则：仅使用ID、类选择符\n2. 不要限定ID选择符：ID选择符左边不用加任何其他选择符\n3. 不要限定类选择符：不要用具体的标签来限定类选择符，而是根据实际情况对类名进行拓展。\n4. 让规则越具体越好\n5. 尽量避免使用后代选择符\n6. 尽量避免使用标签做子选择符\n7. 依靠继承\n8. 仔细检查子选择符的用途\n\n---\n\n## 二. Javascript编码规范\n\n### 1. 一些导致js性能缓慢的例子\n\n- \nDOM访问\n\n执行DOM交互的代码比i一般的js代码要慢。DOM交互是不可避免的，但是尽量的减少。例如，动态的使用innerHTML插入HTML语句比创建DOM节点更快。\n\n- \neval\n\n无论什么时候，避免使用eval方法，因为执行这一方法会造成很大的开销。\n\n- \nwith\n\n尽量不要使用with\n\n- \nfor-in 循环\n\n---\n\n### 2. js陷阱\n\n1. \n避免使用eval和Function constructor\n\n使用eval或者function constructor会加大开销因为每一次脚本引擎调用他们是必须将源码转换成可执行代码；\n\n另外，使用eval时，字符串会在执行时被打断\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace1.png)\n\n2. \n避免使用with\n\n3. \n不要在对性能影响很大的地方使用try-catch-finally\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace2.png)\n\n4. \n避免使用全局变量\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace3.png)\n\n5. \n避免在对性能影响较大的地方使用for-in\n\nfor in循环需要脚本引擎构建一个枚举属性列表，而且每次都要从头重复检查\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace4.png)\n\n6. \n使用字符串累加模式\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace5.png)\n\n7. \n原生的操作比函数更快\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace6.png)\n\n8. \n将函数而不是字符串传到setTimeout()和setInterval()中\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace7.png)\n\n9. \n避免对象里没必要的DOM引用\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace8.png)\n\n10. \n最大化对象解析速度，最小化作用域链\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace9.png)\n\n11. \n尽量让脚本声明的变量短一点，不要太长，特别是循环里面的变量\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace10.png)\n\n12. \n将自身引用存储在作用域外的变量中\n\n当一个funciton被执行时，一个执行的上下文（context）会被创建，被激活的对象将所有自身变量push到上下文（context）的作用域链之前。\n\n离作用域链越远，解析的越慢，这也意味着作用域本地的变量时解析的最快的。\n将自身引用用作用域之外的变量存储，读写都会变的更快，这在全局变量和一些深度查找的资源解析中特别明显。\n\n当然，作用域内定义的变量比使用对象自身访问的速度更快。\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace11.png)\n\n假如你需要在一个大循环中访问一个dom，这样子会更快：\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace12.png)\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace13.png)\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace14.png)\n\n---\n\n### 3. 加载性能一些可以提高的点：\n\n1. \n更快的加载和展现页面可以让js加载没有阻塞\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace15.png)\n\n2. \n添加Experes或者Cache-Control HTTPheader\n\n3. \nGzip javascript和css资源\n\n4. \n利用YUI或者JSMin压缩代码\n\n5. \n尽量减少资源的数目和大小\n\n6. \n让脚本无阻赛并行下载\n\n7. \n合并异步加载的脚本\n\n8. \n将行内脚本放到样式表之上？有待考证，不科学\n\n9. \n少用iframe\n\n---\n\n### 4. 鲜为人知的DOM\n\n#### dom性能缓慢可以归结为一下3个原因：\n\n- 大规模的DOM操作 \n- 脚本触发太多的重构和重绘\n- 定位节点在DOM中的路径慢\n\n#### 解决方案\n\n1. \n尽可能减小DOM的大小\n\n2. \n使用文档的组件模板来进行复用\n\n动态的在dom中插入或者更新元素是代价很大的。一个有效的方法来解决这个问题是利用HTML模板来插入一些对话框或者UI组件。\n\n3. \n最小化重绘和重构的次数\n\n重绘发生在一些元素可见或者隐藏的时候，但是没有改变document的布局\n\n重构发生在DOM的操作方式影响到布局。\n\n重构的代价比重绘大的多得多。\n\n重构表格比重构块状元素代价大\n\n绝对定位的元素不会对document的布局产生影响\n\nDOM的修改会触发重绘\n\n**参考资料**：\n\n- [Repaint and reflow at Opera Developer Network](http://dev.opera.com/articles/view/efficient-javascript/?page=3#reflow)\n- [Notes on HTML Reflow](http://www-archive.mozilla.org/newlayout/doc/reflow.html) - more detailed information on the reflow process (archived)\n- [Reflows & Repaints: CSS Performance making your JavaScript slow](http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/)\n- [Go With The Reflow](http://www.slideshare.net/lsimon/go-with-the-reflow)\n- [Rendering: repaint, reflow/relayout, restyle](http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/)\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace16.png)\n\n4. \n利用cloneNode()\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace17.png)\n\n5. \n利用HTML模板和innerHTML\n\n6. \n设定元素不可见再进行改变（质疑，appendChild不会重发重绘，js执行完成以后才会）\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace18.png)\n\n7. \n尽量少的使用改变元素尺寸或位置的操作\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace19.png)\n\n8. \n使用className来完成多个预定义样式的的改变\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace20.png)\n\n9. \n利用设定属性来动态完成多个样式的设定\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace21.png)\n\n10. \ncss class name vs. style属性\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace22.png)\n\n11. \n不要遍历大量的节点，避免在遍历时改变dom结构\n\n12. \n将DOM元素缓存在变量中使用\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace23.png)\n\n13. \n在dom元素使用完以后移除引用\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace24.png)\n\n---\n\n### 5. 面向对象的Javascript\n\n1. 考虑使用继承机制\n\n---\n\n### 6. client-server对话\n\n1. \n对XMLHttpRequest设定超时时间\n\n2. \n考虑使用约定的数据来做大数据的处理，比如选择xml或者json\n\n---\n\n### 7. 动画\n\n1. \n选择性的使用动画\n\n2. \n使用scrollTo()方法来实现滚动动画\n\n3. \n将动画元素的position设置为absolute或者fix\n\n4. \n在同一时间使用一个timer来服务多个动画元素\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace25.png)\n\n5. \n让动画的速度更平滑\n\n---\n\n### 8. 事件\n\n1. \n利用事件冒泡\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace26.png)\n\n2. \n不要对一些经常触发的event使用代理\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace27.png)\n\n3. \nJavascript调用栈使用setTimeout不会溢出\n\n原因是setTimeout是伪异步的，把函数交给setTimeout处理后，原来的函数不会等待，会继续执行，函数会结束，资源也就可以释放。\n\n而不用setTimeout的时候，函数必须等待调用的函数返回后才能继续执行，但调用的函数又必须等待下一级函数，这样所有函数都不能结束，资源也就释放不出。\n\n换句话说，就是死锁。\n\n---\n\n### 9. 样式\n\n1. \n优化css\n\n2. \n优化图片\n\n---\n","source":"_posts/前端性能优化相关编码规范-day04.md","raw":"---\ntitle:  前端性能优化相关编码规范\ndate: 2018-06-22 14:14:20\ntags: \n    - 前端性能\ncover: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556021941506&di=73676e7ba2dd679207b0dd74b905b3e2&imgtype=0&src=http%3A%2F%2Fwww.33lc.com%2Farticle%2FUploadPic%2F2012-10%2F2012101516255476188.jpg\ncategories: \n    - 大杂烩\n---\n\n### 目录导航\n\n- [前端性能优化相关编码规范](#前端性能优化相关编码规范)\n- [一. css编码规范](#一-css编码规范)\n- [1.避免使用css表达式](#避免使用css表达式)\n- [2.选择使用而不是@import](#选择使用而不是import)\n- [3.避免使用Filter](#避免使用filter)\n- [4.css选择符](#css选择符)\n- [css选择符类型](#css选择符类型)\n- [高效的使用css选择符](#高效的使用css选择符)\n- [编写高效的css选择符](#编写高效的css选择符)\n\n- [二. Javascript编码规范](#二-javascript编码规范)\n- [1. 一些导致js性能缓慢的例子](#一些导致js性能缓慢的例子)\n- [2. js陷阱](#js陷阱)\n- [3. 加载性能一些可以提高的点：](#加载性能一些可以提高的点)\n- [4. 鲜为人知的DOM](#鲜为人知的dom)\n- [dom性能缓慢可以归结为一下3个原因：](#dom性能缓慢可以归结为一下个原因)\n- [解决方案](#解决方案)\n\n- [5. 面向对象的Javascript](#面向对象的javascript)\n- [6. client-server对话](#client-server对话)\n- [7. 动画](#动画)\n- [8. 事件](#事件)\n- [9. 样式](#样式)\n\n# 前端性能优化相关编码规范\n\n> 说明：本文主要介绍在使用HTML、CSS、JS的过程中，需要注意的编码细节和规范\n\n---\n\n## 一. css编码规范\n\n### 1.避免使用css表达式\n\n### 2.选择使用而不是@import\n\n在IE中，使用@import相当于将放在页面底部。\n\n### 3.避免使用Filter\n\n使用filter的问题是它会阻塞渲染并且当浏览在加载图片时，会冻结浏览器。它也会提升内存消耗，它是作用于一个元素而不是一个图片，所以问题会更严重。\n\n最好的解决方案是完全避免使用AlphaImageLoader，用PNG8来代替。\n\n### 4.css选择符\n\ncss选择符的编写方式决定了浏览器必须执行的匹配次数，而某些类型的css选择符将会导致浏览器尝试更多匹配，因此开销比简单选择符更高。\n\n#### **css选择符类型**\n\nID选择符：这种类型的选择符简单且高效，用于匹配页面唯一的元素。#id {}\n\n类选择符.className {}\n\n类型选择符tagName {}\n\n相邻兄弟选择符H1 + #toc {}\n\n子选择符#toc > li {}\n\n后代选择符#toc A {}\n\n通配选择符 * {}\n\n属性选择符 [href=”#index”] {}\n\n伪类和伪元素 A:hover {}\n\n#### **高效的使用css选择符**\n\n*最右边优先：事实上，css选择符是从右到左进行匹配的。*\n\n##### 编写高效的css选择符\n\n1. 避免使用通配规则：仅使用ID、类选择符\n2. 不要限定ID选择符：ID选择符左边不用加任何其他选择符\n3. 不要限定类选择符：不要用具体的标签来限定类选择符，而是根据实际情况对类名进行拓展。\n4. 让规则越具体越好\n5. 尽量避免使用后代选择符\n6. 尽量避免使用标签做子选择符\n7. 依靠继承\n8. 仔细检查子选择符的用途\n\n---\n\n## 二. Javascript编码规范\n\n### 1. 一些导致js性能缓慢的例子\n\n- \nDOM访问\n\n执行DOM交互的代码比i一般的js代码要慢。DOM交互是不可避免的，但是尽量的减少。例如，动态的使用innerHTML插入HTML语句比创建DOM节点更快。\n\n- \neval\n\n无论什么时候，避免使用eval方法，因为执行这一方法会造成很大的开销。\n\n- \nwith\n\n尽量不要使用with\n\n- \nfor-in 循环\n\n---\n\n### 2. js陷阱\n\n1. \n避免使用eval和Function constructor\n\n使用eval或者function constructor会加大开销因为每一次脚本引擎调用他们是必须将源码转换成可执行代码；\n\n另外，使用eval时，字符串会在执行时被打断\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace1.png)\n\n2. \n避免使用with\n\n3. \n不要在对性能影响很大的地方使用try-catch-finally\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace2.png)\n\n4. \n避免使用全局变量\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace3.png)\n\n5. \n避免在对性能影响较大的地方使用for-in\n\nfor in循环需要脚本引擎构建一个枚举属性列表，而且每次都要从头重复检查\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace4.png)\n\n6. \n使用字符串累加模式\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace5.png)\n\n7. \n原生的操作比函数更快\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace6.png)\n\n8. \n将函数而不是字符串传到setTimeout()和setInterval()中\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace7.png)\n\n9. \n避免对象里没必要的DOM引用\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace8.png)\n\n10. \n最大化对象解析速度，最小化作用域链\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace9.png)\n\n11. \n尽量让脚本声明的变量短一点，不要太长，特别是循环里面的变量\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace10.png)\n\n12. \n将自身引用存储在作用域外的变量中\n\n当一个funciton被执行时，一个执行的上下文（context）会被创建，被激活的对象将所有自身变量push到上下文（context）的作用域链之前。\n\n离作用域链越远，解析的越慢，这也意味着作用域本地的变量时解析的最快的。\n将自身引用用作用域之外的变量存储，读写都会变的更快，这在全局变量和一些深度查找的资源解析中特别明显。\n\n当然，作用域内定义的变量比使用对象自身访问的速度更快。\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace11.png)\n\n假如你需要在一个大循环中访问一个dom，这样子会更快：\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace12.png)\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace13.png)\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace14.png)\n\n---\n\n### 3. 加载性能一些可以提高的点：\n\n1. \n更快的加载和展现页面可以让js加载没有阻塞\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace15.png)\n\n2. \n添加Experes或者Cache-Control HTTPheader\n\n3. \nGzip javascript和css资源\n\n4. \n利用YUI或者JSMin压缩代码\n\n5. \n尽量减少资源的数目和大小\n\n6. \n让脚本无阻赛并行下载\n\n7. \n合并异步加载的脚本\n\n8. \n将行内脚本放到样式表之上？有待考证，不科学\n\n9. \n少用iframe\n\n---\n\n### 4. 鲜为人知的DOM\n\n#### dom性能缓慢可以归结为一下3个原因：\n\n- 大规模的DOM操作 \n- 脚本触发太多的重构和重绘\n- 定位节点在DOM中的路径慢\n\n#### 解决方案\n\n1. \n尽可能减小DOM的大小\n\n2. \n使用文档的组件模板来进行复用\n\n动态的在dom中插入或者更新元素是代价很大的。一个有效的方法来解决这个问题是利用HTML模板来插入一些对话框或者UI组件。\n\n3. \n最小化重绘和重构的次数\n\n重绘发生在一些元素可见或者隐藏的时候，但是没有改变document的布局\n\n重构发生在DOM的操作方式影响到布局。\n\n重构的代价比重绘大的多得多。\n\n重构表格比重构块状元素代价大\n\n绝对定位的元素不会对document的布局产生影响\n\nDOM的修改会触发重绘\n\n**参考资料**：\n\n- [Repaint and reflow at Opera Developer Network](http://dev.opera.com/articles/view/efficient-javascript/?page=3#reflow)\n- [Notes on HTML Reflow](http://www-archive.mozilla.org/newlayout/doc/reflow.html) - more detailed information on the reflow process (archived)\n- [Reflows & Repaints: CSS Performance making your JavaScript slow](http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/)\n- [Go With The Reflow](http://www.slideshare.net/lsimon/go-with-the-reflow)\n- [Rendering: repaint, reflow/relayout, restyle](http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/)\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace16.png)\n\n4. \n利用cloneNode()\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace17.png)\n\n5. \n利用HTML模板和innerHTML\n\n6. \n设定元素不可见再进行改变（质疑，appendChild不会重发重绘，js执行完成以后才会）\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace18.png)\n\n7. \n尽量少的使用改变元素尺寸或位置的操作\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace19.png)\n\n8. \n使用className来完成多个预定义样式的的改变\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace20.png)\n\n9. \n利用设定属性来动态完成多个样式的设定\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace21.png)\n\n10. \ncss class name vs. style属性\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace22.png)\n\n11. \n不要遍历大量的节点，避免在遍历时改变dom结构\n\n12. \n将DOM元素缓存在变量中使用\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace23.png)\n\n13. \n在dom元素使用完以后移除引用\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace24.png)\n\n---\n\n### 5. 面向对象的Javascript\n\n1. 考虑使用继承机制\n\n---\n\n### 6. client-server对话\n\n1. \n对XMLHttpRequest设定超时时间\n\n2. \n考虑使用约定的数据来做大数据的处理，比如选择xml或者json\n\n---\n\n### 7. 动画\n\n1. \n选择性的使用动画\n\n2. \n使用scrollTo()方法来实现滚动动画\n\n3. \n将动画元素的position设置为absolute或者fix\n\n4. \n在同一时间使用一个timer来服务多个动画元素\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace25.png)\n\n5. \n让动画的速度更平滑\n\n---\n\n### 8. 事件\n\n1. \n利用事件冒泡\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace26.png)\n\n2. \n不要对一些经常触发的event使用代理\n\n![enter image description here](http://www.xuanfengge.com/netcool/images/performace27.png)\n\n3. \nJavascript调用栈使用setTimeout不会溢出\n\n原因是setTimeout是伪异步的，把函数交给setTimeout处理后，原来的函数不会等待，会继续执行，函数会结束，资源也就可以释放。\n\n而不用setTimeout的时候，函数必须等待调用的函数返回后才能继续执行，但调用的函数又必须等待下一级函数，这样所有函数都不能结束，资源也就释放不出。\n\n换句话说，就是死锁。\n\n---\n\n### 9. 样式\n\n1. \n优化css\n\n2. \n优化图片\n\n---\n","slug":"前端性能优化相关编码规范-day04","published":1,"updated":"2019-04-23T09:41:50.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjutlylg00005zcum17qezq6o","content":"<h3 id=\"目录导航\"><a href=\"#目录导航\" class=\"headerlink\" title=\"目录导航\"></a>目录导航</h3><ul>\n<li><a href=\"#前端性能优化相关编码规范\">前端性能优化相关编码规范</a></li>\n<li><a href=\"#一-css编码规范\">一. css编码规范</a></li>\n<li><a href=\"#避免使用css表达式\">1.避免使用css表达式</a></li>\n<li><a href=\"#选择使用而不是import\">2.选择使用而不是@import</a></li>\n<li><a href=\"#避免使用filter\">3.避免使用Filter</a></li>\n<li><a href=\"#css选择符\">4.css选择符</a></li>\n<li><a href=\"#css选择符类型\">css选择符类型</a></li>\n<li><a href=\"#高效的使用css选择符\">高效的使用css选择符</a></li>\n<li><p><a href=\"#编写高效的css选择符\">编写高效的css选择符</a></p>\n</li>\n<li><p><a href=\"#二-javascript编码规范\">二. Javascript编码规范</a></p>\n</li>\n<li><a href=\"#一些导致js性能缓慢的例子\">1. 一些导致js性能缓慢的例子</a></li>\n<li><a href=\"#js陷阱\">2. js陷阱</a></li>\n<li><a href=\"#加载性能一些可以提高的点\">3. 加载性能一些可以提高的点：</a></li>\n<li><a href=\"#鲜为人知的dom\">4. 鲜为人知的DOM</a></li>\n<li><a href=\"#dom性能缓慢可以归结为一下个原因\">dom性能缓慢可以归结为一下3个原因：</a></li>\n<li><p><a href=\"#解决方案\">解决方案</a></p>\n</li>\n<li><p><a href=\"#面向对象的javascript\">5. 面向对象的Javascript</a></p>\n</li>\n<li><a href=\"#client-server对话\">6. client-server对话</a></li>\n<li><a href=\"#动画\">7. 动画</a></li>\n<li><a href=\"#事件\">8. 事件</a></li>\n<li><a href=\"#样式\">9. 样式</a></li>\n</ul>\n<h1 id=\"前端性能优化相关编码规范\"><a href=\"#前端性能优化相关编码规范\" class=\"headerlink\" title=\"前端性能优化相关编码规范\"></a>前端性能优化相关编码规范</h1><blockquote>\n<p>说明：本文主要介绍在使用HTML、CSS、JS的过程中，需要注意的编码细节和规范</p>\n</blockquote>\n<hr>\n<h2 id=\"一-css编码规范\"><a href=\"#一-css编码规范\" class=\"headerlink\" title=\"一. css编码规范\"></a>一. css编码规范</h2><h3 id=\"1-避免使用css表达式\"><a href=\"#1-避免使用css表达式\" class=\"headerlink\" title=\"1.避免使用css表达式\"></a>1.避免使用css表达式</h3><h3 id=\"2-选择使用而不是-import\"><a href=\"#2-选择使用而不是-import\" class=\"headerlink\" title=\"2.选择使用而不是@import\"></a>2.选择使用而不是@import</h3><p>在IE中，使用@import相当于将放在页面底部。</p>\n<h3 id=\"3-避免使用Filter\"><a href=\"#3-避免使用Filter\" class=\"headerlink\" title=\"3.避免使用Filter\"></a>3.避免使用Filter</h3><p>使用filter的问题是它会阻塞渲染并且当浏览在加载图片时，会冻结浏览器。它也会提升内存消耗，它是作用于一个元素而不是一个图片，所以问题会更严重。</p>\n<p>最好的解决方案是完全避免使用AlphaImageLoader，用PNG8来代替。</p>\n<h3 id=\"4-css选择符\"><a href=\"#4-css选择符\" class=\"headerlink\" title=\"4.css选择符\"></a>4.css选择符</h3><p>css选择符的编写方式决定了浏览器必须执行的匹配次数，而某些类型的css选择符将会导致浏览器尝试更多匹配，因此开销比简单选择符更高。</p>\n<h4 id=\"css选择符类型\"><a href=\"#css选择符类型\" class=\"headerlink\" title=\"css选择符类型\"></a><strong>css选择符类型</strong></h4><p>ID选择符：这种类型的选择符简单且高效，用于匹配页面唯一的元素。#id {}</p>\n<p>类选择符.className {}</p>\n<p>类型选择符tagName {}</p>\n<p>相邻兄弟选择符H1 + #toc {}</p>\n<p>子选择符#toc &gt; li {}</p>\n<p>后代选择符#toc A {}</p>\n<p>通配选择符 * {}</p>\n<p>属性选择符 [href=”#index”] {}</p>\n<p>伪类和伪元素 A:hover {}</p>\n<h4 id=\"高效的使用css选择符\"><a href=\"#高效的使用css选择符\" class=\"headerlink\" title=\"高效的使用css选择符\"></a><strong>高效的使用css选择符</strong></h4><p><em>最右边优先：事实上，css选择符是从右到左进行匹配的。</em></p>\n<h5 id=\"编写高效的css选择符\"><a href=\"#编写高效的css选择符\" class=\"headerlink\" title=\"编写高效的css选择符\"></a>编写高效的css选择符</h5><ol>\n<li>避免使用通配规则：仅使用ID、类选择符</li>\n<li>不要限定ID选择符：ID选择符左边不用加任何其他选择符</li>\n<li>不要限定类选择符：不要用具体的标签来限定类选择符，而是根据实际情况对类名进行拓展。</li>\n<li>让规则越具体越好</li>\n<li>尽量避免使用后代选择符</li>\n<li>尽量避免使用标签做子选择符</li>\n<li>依靠继承</li>\n<li>仔细检查子选择符的用途</li>\n</ol>\n<hr>\n<h2 id=\"二-Javascript编码规范\"><a href=\"#二-Javascript编码规范\" class=\"headerlink\" title=\"二. Javascript编码规范\"></a>二. Javascript编码规范</h2><h3 id=\"1-一些导致js性能缓慢的例子\"><a href=\"#1-一些导致js性能缓慢的例子\" class=\"headerlink\" title=\"1. 一些导致js性能缓慢的例子\"></a>1. 一些导致js性能缓慢的例子</h3><ul>\n<li>DOM访问</li>\n</ul>\n<p>执行DOM交互的代码比i一般的js代码要慢。DOM交互是不可避免的，但是尽量的减少。例如，动态的使用innerHTML插入HTML语句比创建DOM节点更快。</p>\n<ul>\n<li>eval</li>\n</ul>\n<p>无论什么时候，避免使用eval方法，因为执行这一方法会造成很大的开销。</p>\n<ul>\n<li>with</li>\n</ul>\n<p>尽量不要使用with</p>\n<ul>\n<li>for-in 循环</li>\n</ul>\n<hr>\n<h3 id=\"2-js陷阱\"><a href=\"#2-js陷阱\" class=\"headerlink\" title=\"2. js陷阱\"></a>2. js陷阱</h3><ol>\n<li>避免使用eval和Function constructor</li>\n</ol>\n<p>使用eval或者function constructor会加大开销因为每一次脚本引擎调用他们是必须将源码转换成可执行代码；</p>\n<p>另外，使用eval时，字符串会在执行时被打断</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace1.png\" alt=\"enter image description here\"></p>\n<ol start=\"2\">\n<li><p>避免使用with</p>\n</li>\n<li><p>不要在对性能影响很大的地方使用try-catch-finally</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace2.png\" alt=\"enter image description here\"></p>\n<ol start=\"4\">\n<li>避免使用全局变量</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace3.png\" alt=\"enter image description here\"></p>\n<ol start=\"5\">\n<li>避免在对性能影响较大的地方使用for-in</li>\n</ol>\n<p>for in循环需要脚本引擎构建一个枚举属性列表，而且每次都要从头重复检查</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace4.png\" alt=\"enter image description here\"></p>\n<ol start=\"6\">\n<li>使用字符串累加模式</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace5.png\" alt=\"enter image description here\"></p>\n<ol start=\"7\">\n<li>原生的操作比函数更快</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace6.png\" alt=\"enter image description here\"></p>\n<ol start=\"8\">\n<li>将函数而不是字符串传到setTimeout()和setInterval()中</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace7.png\" alt=\"enter image description here\"></p>\n<ol start=\"9\">\n<li>避免对象里没必要的DOM引用</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace8.png\" alt=\"enter image description here\"></p>\n<ol start=\"10\">\n<li>最大化对象解析速度，最小化作用域链</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace9.png\" alt=\"enter image description here\"></p>\n<ol start=\"11\">\n<li>尽量让脚本声明的变量短一点，不要太长，特别是循环里面的变量</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace10.png\" alt=\"enter image description here\"></p>\n<ol start=\"12\">\n<li>将自身引用存储在作用域外的变量中</li>\n</ol>\n<p>当一个funciton被执行时，一个执行的上下文（context）会被创建，被激活的对象将所有自身变量push到上下文（context）的作用域链之前。</p>\n<p>离作用域链越远，解析的越慢，这也意味着作用域本地的变量时解析的最快的。<br>将自身引用用作用域之外的变量存储，读写都会变的更快，这在全局变量和一些深度查找的资源解析中特别明显。</p>\n<p>当然，作用域内定义的变量比使用对象自身访问的速度更快。</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace11.png\" alt=\"enter image description here\"></p>\n<p>假如你需要在一个大循环中访问一个dom，这样子会更快：</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace12.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace13.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace14.png\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"3-加载性能一些可以提高的点：\"><a href=\"#3-加载性能一些可以提高的点：\" class=\"headerlink\" title=\"3. 加载性能一些可以提高的点：\"></a>3. 加载性能一些可以提高的点：</h3><ol>\n<li>更快的加载和展现页面可以让js加载没有阻塞</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace15.png\" alt=\"enter image description here\"></p>\n<ol start=\"2\">\n<li><p>添加Experes或者Cache-Control HTTPheader</p>\n</li>\n<li><p>Gzip javascript和css资源</p>\n</li>\n<li><p>利用YUI或者JSMin压缩代码</p>\n</li>\n<li><p>尽量减少资源的数目和大小</p>\n</li>\n<li><p>让脚本无阻赛并行下载</p>\n</li>\n<li><p>合并异步加载的脚本</p>\n</li>\n<li><p>将行内脚本放到样式表之上？有待考证，不科学</p>\n</li>\n<li><p>少用iframe</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"4-鲜为人知的DOM\"><a href=\"#4-鲜为人知的DOM\" class=\"headerlink\" title=\"4. 鲜为人知的DOM\"></a>4. 鲜为人知的DOM</h3><h4 id=\"dom性能缓慢可以归结为一下3个原因：\"><a href=\"#dom性能缓慢可以归结为一下3个原因：\" class=\"headerlink\" title=\"dom性能缓慢可以归结为一下3个原因：\"></a>dom性能缓慢可以归结为一下3个原因：</h4><ul>\n<li>大规模的DOM操作 </li>\n<li>脚本触发太多的重构和重绘</li>\n<li>定位节点在DOM中的路径慢</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ol>\n<li><p>尽可能减小DOM的大小</p>\n</li>\n<li><p>使用文档的组件模板来进行复用</p>\n</li>\n</ol>\n<p>动态的在dom中插入或者更新元素是代价很大的。一个有效的方法来解决这个问题是利用HTML模板来插入一些对话框或者UI组件。</p>\n<ol start=\"3\">\n<li>最小化重绘和重构的次数</li>\n</ol>\n<p>重绘发生在一些元素可见或者隐藏的时候，但是没有改变document的布局</p>\n<p>重构发生在DOM的操作方式影响到布局。</p>\n<p>重构的代价比重绘大的多得多。</p>\n<p>重构表格比重构块状元素代价大</p>\n<p>绝对定位的元素不会对document的布局产生影响</p>\n<p>DOM的修改会触发重绘</p>\n<p><strong>参考资料</strong>：</p>\n<ul>\n<li><a href=\"http://dev.opera.com/articles/view/efficient-javascript/?page=3#reflow\" target=\"_blank\" rel=\"noopener\">Repaint and reflow at Opera Developer Network</a></li>\n<li><a href=\"http://www-archive.mozilla.org/newlayout/doc/reflow.html\" target=\"_blank\" rel=\"noopener\">Notes on HTML Reflow</a> - more detailed information on the reflow process (archived)</li>\n<li><a href=\"http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/\" target=\"_blank\" rel=\"noopener\">Reflows &amp; Repaints: CSS Performance making your JavaScript slow</a></li>\n<li><a href=\"http://www.slideshare.net/lsimon/go-with-the-reflow\" target=\"_blank\" rel=\"noopener\">Go With The Reflow</a></li>\n<li><a href=\"http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/\" target=\"_blank\" rel=\"noopener\">Rendering: repaint, reflow/relayout, restyle</a></li>\n</ul>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace16.png\" alt=\"enter image description here\"></p>\n<ol start=\"4\">\n<li>利用cloneNode()</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace17.png\" alt=\"enter image description here\"></p>\n<ol start=\"5\">\n<li><p>利用HTML模板和innerHTML</p>\n</li>\n<li><p>设定元素不可见再进行改变（质疑，appendChild不会重发重绘，js执行完成以后才会）</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace18.png\" alt=\"enter image description here\"></p>\n<ol start=\"7\">\n<li>尽量少的使用改变元素尺寸或位置的操作</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace19.png\" alt=\"enter image description here\"></p>\n<ol start=\"8\">\n<li>使用className来完成多个预定义样式的的改变</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace20.png\" alt=\"enter image description here\"></p>\n<ol start=\"9\">\n<li>利用设定属性来动态完成多个样式的设定</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace21.png\" alt=\"enter image description here\"></p>\n<ol start=\"10\">\n<li>css class name vs. style属性</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace22.png\" alt=\"enter image description here\"></p>\n<ol start=\"11\">\n<li><p>不要遍历大量的节点，避免在遍历时改变dom结构</p>\n</li>\n<li><p>将DOM元素缓存在变量中使用</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace23.png\" alt=\"enter image description here\"></p>\n<ol start=\"13\">\n<li>在dom元素使用完以后移除引用</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace24.png\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"5-面向对象的Javascript\"><a href=\"#5-面向对象的Javascript\" class=\"headerlink\" title=\"5. 面向对象的Javascript\"></a>5. 面向对象的Javascript</h3><ol>\n<li>考虑使用继承机制</li>\n</ol>\n<hr>\n<h3 id=\"6-client-server对话\"><a href=\"#6-client-server对话\" class=\"headerlink\" title=\"6. client-server对话\"></a>6. client-server对话</h3><ol>\n<li><p>对XMLHttpRequest设定超时时间</p>\n</li>\n<li><p>考虑使用约定的数据来做大数据的处理，比如选择xml或者json</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"7-动画\"><a href=\"#7-动画\" class=\"headerlink\" title=\"7. 动画\"></a>7. 动画</h3><ol>\n<li><p>选择性的使用动画</p>\n</li>\n<li><p>使用scrollTo()方法来实现滚动动画</p>\n</li>\n<li><p>将动画元素的position设置为absolute或者fix</p>\n</li>\n<li><p>在同一时间使用一个timer来服务多个动画元素</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace25.png\" alt=\"enter image description here\"></p>\n<ol start=\"5\">\n<li>让动画的速度更平滑</li>\n</ol>\n<hr>\n<h3 id=\"8-事件\"><a href=\"#8-事件\" class=\"headerlink\" title=\"8. 事件\"></a>8. 事件</h3><ol>\n<li>利用事件冒泡</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace26.png\" alt=\"enter image description here\"></p>\n<ol start=\"2\">\n<li>不要对一些经常触发的event使用代理</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace27.png\" alt=\"enter image description here\"></p>\n<ol start=\"3\">\n<li>Javascript调用栈使用setTimeout不会溢出</li>\n</ol>\n<p>原因是setTimeout是伪异步的，把函数交给setTimeout处理后，原来的函数不会等待，会继续执行，函数会结束，资源也就可以释放。</p>\n<p>而不用setTimeout的时候，函数必须等待调用的函数返回后才能继续执行，但调用的函数又必须等待下一级函数，这样所有函数都不能结束，资源也就释放不出。</p>\n<p>换句话说，就是死锁。</p>\n<hr>\n<h3 id=\"9-样式\"><a href=\"#9-样式\" class=\"headerlink\" title=\"9. 样式\"></a>9. 样式</h3><ol>\n<li><p>优化css</p>\n</li>\n<li><p>优化图片</p>\n</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"目录导航\"><a href=\"#目录导航\" class=\"headerlink\" title=\"目录导航\"></a>目录导航</h3><ul>\n<li><a href=\"#前端性能优化相关编码规范\">前端性能优化相关编码规范</a></li>\n<li><a href=\"#一-css编码规范\">一. css编码规范</a></li>\n<li><a href=\"#避免使用css表达式\">1.避免使用css表达式</a></li>\n<li><a href=\"#选择使用而不是import\">2.选择使用而不是@import</a></li>\n<li><a href=\"#避免使用filter\">3.避免使用Filter</a></li>\n<li><a href=\"#css选择符\">4.css选择符</a></li>\n<li><a href=\"#css选择符类型\">css选择符类型</a></li>\n<li><a href=\"#高效的使用css选择符\">高效的使用css选择符</a></li>\n<li><p><a href=\"#编写高效的css选择符\">编写高效的css选择符</a></p>\n</li>\n<li><p><a href=\"#二-javascript编码规范\">二. Javascript编码规范</a></p>\n</li>\n<li><a href=\"#一些导致js性能缓慢的例子\">1. 一些导致js性能缓慢的例子</a></li>\n<li><a href=\"#js陷阱\">2. js陷阱</a></li>\n<li><a href=\"#加载性能一些可以提高的点\">3. 加载性能一些可以提高的点：</a></li>\n<li><a href=\"#鲜为人知的dom\">4. 鲜为人知的DOM</a></li>\n<li><a href=\"#dom性能缓慢可以归结为一下个原因\">dom性能缓慢可以归结为一下3个原因：</a></li>\n<li><p><a href=\"#解决方案\">解决方案</a></p>\n</li>\n<li><p><a href=\"#面向对象的javascript\">5. 面向对象的Javascript</a></p>\n</li>\n<li><a href=\"#client-server对话\">6. client-server对话</a></li>\n<li><a href=\"#动画\">7. 动画</a></li>\n<li><a href=\"#事件\">8. 事件</a></li>\n<li><a href=\"#样式\">9. 样式</a></li>\n</ul>\n<h1 id=\"前端性能优化相关编码规范\"><a href=\"#前端性能优化相关编码规范\" class=\"headerlink\" title=\"前端性能优化相关编码规范\"></a>前端性能优化相关编码规范</h1><blockquote>\n<p>说明：本文主要介绍在使用HTML、CSS、JS的过程中，需要注意的编码细节和规范</p>\n</blockquote>\n<hr>\n<h2 id=\"一-css编码规范\"><a href=\"#一-css编码规范\" class=\"headerlink\" title=\"一. css编码规范\"></a>一. css编码规范</h2><h3 id=\"1-避免使用css表达式\"><a href=\"#1-避免使用css表达式\" class=\"headerlink\" title=\"1.避免使用css表达式\"></a>1.避免使用css表达式</h3><h3 id=\"2-选择使用而不是-import\"><a href=\"#2-选择使用而不是-import\" class=\"headerlink\" title=\"2.选择使用而不是@import\"></a>2.选择使用而不是@import</h3><p>在IE中，使用@import相当于将放在页面底部。</p>\n<h3 id=\"3-避免使用Filter\"><a href=\"#3-避免使用Filter\" class=\"headerlink\" title=\"3.避免使用Filter\"></a>3.避免使用Filter</h3><p>使用filter的问题是它会阻塞渲染并且当浏览在加载图片时，会冻结浏览器。它也会提升内存消耗，它是作用于一个元素而不是一个图片，所以问题会更严重。</p>\n<p>最好的解决方案是完全避免使用AlphaImageLoader，用PNG8来代替。</p>\n<h3 id=\"4-css选择符\"><a href=\"#4-css选择符\" class=\"headerlink\" title=\"4.css选择符\"></a>4.css选择符</h3><p>css选择符的编写方式决定了浏览器必须执行的匹配次数，而某些类型的css选择符将会导致浏览器尝试更多匹配，因此开销比简单选择符更高。</p>\n<h4 id=\"css选择符类型\"><a href=\"#css选择符类型\" class=\"headerlink\" title=\"css选择符类型\"></a><strong>css选择符类型</strong></h4><p>ID选择符：这种类型的选择符简单且高效，用于匹配页面唯一的元素。#id {}</p>\n<p>类选择符.className {}</p>\n<p>类型选择符tagName {}</p>\n<p>相邻兄弟选择符H1 + #toc {}</p>\n<p>子选择符#toc &gt; li {}</p>\n<p>后代选择符#toc A {}</p>\n<p>通配选择符 * {}</p>\n<p>属性选择符 [href=”#index”] {}</p>\n<p>伪类和伪元素 A:hover {}</p>\n<h4 id=\"高效的使用css选择符\"><a href=\"#高效的使用css选择符\" class=\"headerlink\" title=\"高效的使用css选择符\"></a><strong>高效的使用css选择符</strong></h4><p><em>最右边优先：事实上，css选择符是从右到左进行匹配的。</em></p>\n<h5 id=\"编写高效的css选择符\"><a href=\"#编写高效的css选择符\" class=\"headerlink\" title=\"编写高效的css选择符\"></a>编写高效的css选择符</h5><ol>\n<li>避免使用通配规则：仅使用ID、类选择符</li>\n<li>不要限定ID选择符：ID选择符左边不用加任何其他选择符</li>\n<li>不要限定类选择符：不要用具体的标签来限定类选择符，而是根据实际情况对类名进行拓展。</li>\n<li>让规则越具体越好</li>\n<li>尽量避免使用后代选择符</li>\n<li>尽量避免使用标签做子选择符</li>\n<li>依靠继承</li>\n<li>仔细检查子选择符的用途</li>\n</ol>\n<hr>\n<h2 id=\"二-Javascript编码规范\"><a href=\"#二-Javascript编码规范\" class=\"headerlink\" title=\"二. Javascript编码规范\"></a>二. Javascript编码规范</h2><h3 id=\"1-一些导致js性能缓慢的例子\"><a href=\"#1-一些导致js性能缓慢的例子\" class=\"headerlink\" title=\"1. 一些导致js性能缓慢的例子\"></a>1. 一些导致js性能缓慢的例子</h3><ul>\n<li>DOM访问</li>\n</ul>\n<p>执行DOM交互的代码比i一般的js代码要慢。DOM交互是不可避免的，但是尽量的减少。例如，动态的使用innerHTML插入HTML语句比创建DOM节点更快。</p>\n<ul>\n<li>eval</li>\n</ul>\n<p>无论什么时候，避免使用eval方法，因为执行这一方法会造成很大的开销。</p>\n<ul>\n<li>with</li>\n</ul>\n<p>尽量不要使用with</p>\n<ul>\n<li>for-in 循环</li>\n</ul>\n<hr>\n<h3 id=\"2-js陷阱\"><a href=\"#2-js陷阱\" class=\"headerlink\" title=\"2. js陷阱\"></a>2. js陷阱</h3><ol>\n<li>避免使用eval和Function constructor</li>\n</ol>\n<p>使用eval或者function constructor会加大开销因为每一次脚本引擎调用他们是必须将源码转换成可执行代码；</p>\n<p>另外，使用eval时，字符串会在执行时被打断</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace1.png\" alt=\"enter image description here\"></p>\n<ol start=\"2\">\n<li><p>避免使用with</p>\n</li>\n<li><p>不要在对性能影响很大的地方使用try-catch-finally</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace2.png\" alt=\"enter image description here\"></p>\n<ol start=\"4\">\n<li>避免使用全局变量</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace3.png\" alt=\"enter image description here\"></p>\n<ol start=\"5\">\n<li>避免在对性能影响较大的地方使用for-in</li>\n</ol>\n<p>for in循环需要脚本引擎构建一个枚举属性列表，而且每次都要从头重复检查</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace4.png\" alt=\"enter image description here\"></p>\n<ol start=\"6\">\n<li>使用字符串累加模式</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace5.png\" alt=\"enter image description here\"></p>\n<ol start=\"7\">\n<li>原生的操作比函数更快</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace6.png\" alt=\"enter image description here\"></p>\n<ol start=\"8\">\n<li>将函数而不是字符串传到setTimeout()和setInterval()中</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace7.png\" alt=\"enter image description here\"></p>\n<ol start=\"9\">\n<li>避免对象里没必要的DOM引用</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace8.png\" alt=\"enter image description here\"></p>\n<ol start=\"10\">\n<li>最大化对象解析速度，最小化作用域链</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace9.png\" alt=\"enter image description here\"></p>\n<ol start=\"11\">\n<li>尽量让脚本声明的变量短一点，不要太长，特别是循环里面的变量</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace10.png\" alt=\"enter image description here\"></p>\n<ol start=\"12\">\n<li>将自身引用存储在作用域外的变量中</li>\n</ol>\n<p>当一个funciton被执行时，一个执行的上下文（context）会被创建，被激活的对象将所有自身变量push到上下文（context）的作用域链之前。</p>\n<p>离作用域链越远，解析的越慢，这也意味着作用域本地的变量时解析的最快的。<br>将自身引用用作用域之外的变量存储，读写都会变的更快，这在全局变量和一些深度查找的资源解析中特别明显。</p>\n<p>当然，作用域内定义的变量比使用对象自身访问的速度更快。</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace11.png\" alt=\"enter image description here\"></p>\n<p>假如你需要在一个大循环中访问一个dom，这样子会更快：</p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace12.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace13.png\" alt=\"enter image description here\"></p>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace14.png\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"3-加载性能一些可以提高的点：\"><a href=\"#3-加载性能一些可以提高的点：\" class=\"headerlink\" title=\"3. 加载性能一些可以提高的点：\"></a>3. 加载性能一些可以提高的点：</h3><ol>\n<li>更快的加载和展现页面可以让js加载没有阻塞</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace15.png\" alt=\"enter image description here\"></p>\n<ol start=\"2\">\n<li><p>添加Experes或者Cache-Control HTTPheader</p>\n</li>\n<li><p>Gzip javascript和css资源</p>\n</li>\n<li><p>利用YUI或者JSMin压缩代码</p>\n</li>\n<li><p>尽量减少资源的数目和大小</p>\n</li>\n<li><p>让脚本无阻赛并行下载</p>\n</li>\n<li><p>合并异步加载的脚本</p>\n</li>\n<li><p>将行内脚本放到样式表之上？有待考证，不科学</p>\n</li>\n<li><p>少用iframe</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"4-鲜为人知的DOM\"><a href=\"#4-鲜为人知的DOM\" class=\"headerlink\" title=\"4. 鲜为人知的DOM\"></a>4. 鲜为人知的DOM</h3><h4 id=\"dom性能缓慢可以归结为一下3个原因：\"><a href=\"#dom性能缓慢可以归结为一下3个原因：\" class=\"headerlink\" title=\"dom性能缓慢可以归结为一下3个原因：\"></a>dom性能缓慢可以归结为一下3个原因：</h4><ul>\n<li>大规模的DOM操作 </li>\n<li>脚本触发太多的重构和重绘</li>\n<li>定位节点在DOM中的路径慢</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ol>\n<li><p>尽可能减小DOM的大小</p>\n</li>\n<li><p>使用文档的组件模板来进行复用</p>\n</li>\n</ol>\n<p>动态的在dom中插入或者更新元素是代价很大的。一个有效的方法来解决这个问题是利用HTML模板来插入一些对话框或者UI组件。</p>\n<ol start=\"3\">\n<li>最小化重绘和重构的次数</li>\n</ol>\n<p>重绘发生在一些元素可见或者隐藏的时候，但是没有改变document的布局</p>\n<p>重构发生在DOM的操作方式影响到布局。</p>\n<p>重构的代价比重绘大的多得多。</p>\n<p>重构表格比重构块状元素代价大</p>\n<p>绝对定位的元素不会对document的布局产生影响</p>\n<p>DOM的修改会触发重绘</p>\n<p><strong>参考资料</strong>：</p>\n<ul>\n<li><a href=\"http://dev.opera.com/articles/view/efficient-javascript/?page=3#reflow\" target=\"_blank\" rel=\"noopener\">Repaint and reflow at Opera Developer Network</a></li>\n<li><a href=\"http://www-archive.mozilla.org/newlayout/doc/reflow.html\" target=\"_blank\" rel=\"noopener\">Notes on HTML Reflow</a> - more detailed information on the reflow process (archived)</li>\n<li><a href=\"http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/\" target=\"_blank\" rel=\"noopener\">Reflows &amp; Repaints: CSS Performance making your JavaScript slow</a></li>\n<li><a href=\"http://www.slideshare.net/lsimon/go-with-the-reflow\" target=\"_blank\" rel=\"noopener\">Go With The Reflow</a></li>\n<li><a href=\"http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/\" target=\"_blank\" rel=\"noopener\">Rendering: repaint, reflow/relayout, restyle</a></li>\n</ul>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace16.png\" alt=\"enter image description here\"></p>\n<ol start=\"4\">\n<li>利用cloneNode()</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace17.png\" alt=\"enter image description here\"></p>\n<ol start=\"5\">\n<li><p>利用HTML模板和innerHTML</p>\n</li>\n<li><p>设定元素不可见再进行改变（质疑，appendChild不会重发重绘，js执行完成以后才会）</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace18.png\" alt=\"enter image description here\"></p>\n<ol start=\"7\">\n<li>尽量少的使用改变元素尺寸或位置的操作</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace19.png\" alt=\"enter image description here\"></p>\n<ol start=\"8\">\n<li>使用className来完成多个预定义样式的的改变</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace20.png\" alt=\"enter image description here\"></p>\n<ol start=\"9\">\n<li>利用设定属性来动态完成多个样式的设定</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace21.png\" alt=\"enter image description here\"></p>\n<ol start=\"10\">\n<li>css class name vs. style属性</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace22.png\" alt=\"enter image description here\"></p>\n<ol start=\"11\">\n<li><p>不要遍历大量的节点，避免在遍历时改变dom结构</p>\n</li>\n<li><p>将DOM元素缓存在变量中使用</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace23.png\" alt=\"enter image description here\"></p>\n<ol start=\"13\">\n<li>在dom元素使用完以后移除引用</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace24.png\" alt=\"enter image description here\"></p>\n<hr>\n<h3 id=\"5-面向对象的Javascript\"><a href=\"#5-面向对象的Javascript\" class=\"headerlink\" title=\"5. 面向对象的Javascript\"></a>5. 面向对象的Javascript</h3><ol>\n<li>考虑使用继承机制</li>\n</ol>\n<hr>\n<h3 id=\"6-client-server对话\"><a href=\"#6-client-server对话\" class=\"headerlink\" title=\"6. client-server对话\"></a>6. client-server对话</h3><ol>\n<li><p>对XMLHttpRequest设定超时时间</p>\n</li>\n<li><p>考虑使用约定的数据来做大数据的处理，比如选择xml或者json</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"7-动画\"><a href=\"#7-动画\" class=\"headerlink\" title=\"7. 动画\"></a>7. 动画</h3><ol>\n<li><p>选择性的使用动画</p>\n</li>\n<li><p>使用scrollTo()方法来实现滚动动画</p>\n</li>\n<li><p>将动画元素的position设置为absolute或者fix</p>\n</li>\n<li><p>在同一时间使用一个timer来服务多个动画元素</p>\n</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace25.png\" alt=\"enter image description here\"></p>\n<ol start=\"5\">\n<li>让动画的速度更平滑</li>\n</ol>\n<hr>\n<h3 id=\"8-事件\"><a href=\"#8-事件\" class=\"headerlink\" title=\"8. 事件\"></a>8. 事件</h3><ol>\n<li>利用事件冒泡</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace26.png\" alt=\"enter image description here\"></p>\n<ol start=\"2\">\n<li>不要对一些经常触发的event使用代理</li>\n</ol>\n<p><img src=\"http://www.xuanfengge.com/netcool/images/performace27.png\" alt=\"enter image description here\"></p>\n<ol start=\"3\">\n<li>Javascript调用栈使用setTimeout不会溢出</li>\n</ol>\n<p>原因是setTimeout是伪异步的，把函数交给setTimeout处理后，原来的函数不会等待，会继续执行，函数会结束，资源也就可以释放。</p>\n<p>而不用setTimeout的时候，函数必须等待调用的函数返回后才能继续执行，但调用的函数又必须等待下一级函数，这样所有函数都不能结束，资源也就释放不出。</p>\n<p>换句话说，就是死锁。</p>\n<hr>\n<h3 id=\"9-样式\"><a href=\"#9-样式\" class=\"headerlink\" title=\"9. 样式\"></a>9. 样式</h3><ol>\n<li><p>优化css</p>\n</li>\n<li><p>优化图片</p>\n</li>\n</ol>\n<hr>\n"},{"title":"前端JS规范文档","date":"2018-05-12T10:34:20.000Z","cover":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556021977157&di=ca5a227f59250179324d49264938cfc7&imgtype=0&src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F591245435ade8c91e3e22e90d23d80b8.jpeg","_content":"\n### 目录导航\n\n*   [前端javascript规范文档](#前端javascript规范文档)\n    *   [一、规范目的](#一规范目的)\n    *   [二、基本准则](#二基本准则)\n    *   [三、命名规范](#三命名规范)\n        *   [1\\. 目的](#目的)\n        *   [2\\. 变量名](#变量名)\n        *   [3\\. 构造函数（类）命名](#构造函数类命名)\n        *   [4\\. 普通变量命名](#普通变量命名)\n        *   [5\\. 匈牙利命名法](#匈牙利命名法)\n        *   [6\\. 其他前缀规范](#其他前缀规范)\n        *   [7\\. 例外情况](#例外情况)\n        *   [8\\. 函数命名](#函数命名)\n        *   [9\\. 变量命名例子](#变量命名例子)\n    *   [四、编写注释](#四编写注释)\n    *   [五、使用空格](#五使用空格)\n    *   [六、编写API文档](#六编写api文档)\n        *   [1\\. 生成API文档的步骤：](#生成api文档的步骤)\n        *   [2\\. 编写API目的：](#编写api目的)\n    *   [七、推荐写法](#七推荐写法)\n    *   [八、不规范写法](#八不规范写法)\n    *   [九、需要注意的地方](#九需要注意的地方)\n    *   [十、扩展阅读：](#十扩展阅读)\n\n前端javascript规范文档\n================\n\n> 说明：本文档为前端JS规范\n\n* * *\n\n一、规范目的\n------\n\n为提高团队协作效率，便于前端后期优化维护，输出高质量的文档。\n\n* * *\n\n二、基本准则\n------\n\n*   符合web标准，结构表现行为分离，兼容性优良。页面性能方面，代码要求简洁明了有序， 尽可能的减小服务器负载，保证最快的解析速度。\n*   项目的维护和二次开发可能是直接或间接的团队合作，所以创建易维护的代码是一个项目成功与否的关键，易维护的代码意味着具有如下特性：\n    *   阅读性好：如良好的注释和命名规范，有文档\n    *   具有一致性：看起来如同一个人编写\n    *   代码的松耦合，高度模块化：将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从html,css,js三个层面都要考虑模块化\n    *   严格按照规范编写代码\n\n* * *\n\n三、命名规范\n------\n\n### 1\\. 目的\n\n提高代码可预测性和可维护性的方法是使用命名约定，这就意味着采用一致的方法来对变量和函数进行命名。\n\n### 2\\. 变量名\n\n变量名包括全局变量，局部变量，类变量，函数参数\n\n### 3\\. 构造函数（类）命名\n\n首字母大写，驼峰式命名。\n\nJS中没有类，但是可以用new调用构造函数：var man = new Person();\n\n### 4\\. 普通变量命名\n\n首字母小写，驼峰式命名，匈牙利命名\n\n如：nCheckCount 表示整形的数值\n\n### 5\\. 匈牙利命名法\n\n匈牙利命名法语法：变量名＝类型＋对象描述\n\n*   类型指变量的类型\n*   对象描述指对象名字全称或名字的一部分，要求有明确含义，命名要容易记忆容易理解。\n\n**提示**: 虽然JavaScript变量表面上没有类型，但是JavaScript内部还是会为变量赋予相应的类型\n\nJavaScript变量起名类型\n\n变量命名前缀\n\n举例\n\nArray 数组\n\na\n\naList，aGroup\n\nBoolean 逻辑\n\nb\n\nbChecked，bHasLogin\n\nFunction 函数\n\nf\n\nfGetHtml，fInit\n\nInteger 数字\n\nn\n\nnPage，nTotal\n\nObject 对象\n\no\n\noButton，oDate\n\nRegular Expression 正则\n\nr\n\nrDomain，rEmail\n\nString 字符\n\ns\n\nsName，sHtml\n\n### 6\\. 其他前缀规范\n\n可根据团队及项目需要增加\n\n*   $：表示Jquery对象\n    \n    例如：$Content，$Module，一种比较广泛的Jquery对象变量命名规范。\n    \n*   fn：表示函数\n    \n    例如：fnGetName，fnSetAge；和上面函数的前缀略有不同，改用fn来代替，个人认为fn能够更好的区分普通变量和函数变量。\n    \n\n### 7\\. 例外情况\n\n以根据项目及团队需要，设计出针对项目需要的前缀规范，从而达到团队开发协作便利的目的。\n\n*   作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr。\n*   循环变量可以简写，比如：i，j，k等。\n*   某些作为不允许修改值的变量认为是常量，全部字母都大写。例如：COPYRIGHT，PI。常量可以存在于函数中，也可以存在于全局。必须采用全大写的命名，且单词以_分割，常量通常用于ajax请求url，和一些不会改变的数据。\n\n### 8\\. 函数命名\n\n**普通函数**：首字母小写，驼峰式命名，统一使用动词或者动词+名词形式\n\n例如：fnGetVersion()，fnSubmitForm()，fnInit()；涉及返回逻辑值的函数可以使用is，has，contains等表示逻辑的词语代替动词，例如：fnIsObject()，fnHasClass()，fnContainsElment()。\n\n**内部函数**：使用_fn+动词+名词形式，内部函数必需在函数最后定义。\n\n例如：\n\n    function fnGetNumber(nTotal) {\n        if (nTotal < 100) {\n            nTotal = 100;\n        }\n        return _fnAdd(nTotal);\n    \n        function _fnAdd(nNumber) {\n            nNumber++;\n            return nNumber;\n        }\n    }\n    alert(fGetNumber(10)); //alert 101\n    \n\n**对象方法与事件响应函数**：对象方法命名使用fn+对象类名+动词+名词形式；\n\n例如： fnAddressGetEmail()，\n\n**事件响应函数**：fn+触发事件对象名+事件名或者模块名\n\n例如：fnDivClick()，fnAddressSubmitButtonClick()\n\n**函数方法常用的动词**：\n\n    get 获取/set 设置,\n    add 增加/remove 删除\n    create 创建/destory 移除\n    start 启动/stop 停止\n    open 打开/close 关闭,\n    read 读取/write 写入\n    load 载入/save 保存,\n    create 创建/destroy 销毁\n    begin 开始/end 结束,\n    backup 备份/restore 恢复\n    import 导入/export 导出,\n    split 分割/merge 合并\n    inject 注入/extract 提取,\n    attach 附着/detach 脱离\n    bind 绑定/separate 分离,\n    view 查看/browse 浏览\n    edit 编辑/modify 修改,\n    select 选取/mark 标记\n    copy 复制/paste 粘贴,\n    undo 撤销/redo 重做\n    insert 插入/delete 移除,\n    add 加入/append 添加\n    clean 清理/clear 清除,\n    index 索引/sort 排序\n    find 查找/search 搜索,\n    increase 增加/decrease 减少\n    play 播放/pause 暂停,\n    launch 启动/run 运行\n    compile 编译/execute 执行,\n    debug 调试/trace 跟踪\n    observe 观察/listen 监听,\n    build 构建/publish 发布\n    input 输入/output 输出,\n    encode 编码/decode 解码\n    encrypt 加密/decrypt 解密,\n    compress 压缩/decompress 解压缩\n    pack 打包/unpack 解包,\n    parse 解析/emit 生成\n    connect 连接/disconnect 断开,\n    send 发送/receive 接收\n    download 下载/upload 上传,\n    refresh 刷新/synchronize 同步\n    update 更新/revert 复原,\n    lock 锁定/unlock 解锁\n    check out 签出/check in 签入,\n    submit 提交/commit 交付\n    push 推/pull 拉,\n    expand 展开/collapse 折叠\n    begin 起始/end 结束,\n    start 开始/finish 完成\n    enter 进入/exit 退出,\n    abort 放弃/quit 离开\n    obsolete 废弃/depreciate 废旧,\n    collect 收集/aggregate 聚集\n    \n\n### 9\\. 变量命名例子\n\n*   为什么需要这样强制定义变量前缀？正式因为javascript是弱语言造成的。在定义大量变量的时候，我们需要很明确的知道当前变量是什么属性，如果只通过普通单词，是很难区分的。\n    \n    普通代码\n    \n        var checked = false;\n        var check = function() {\n            return true;\n        }\n        /**\n        some code\n        **/\n        \n        if(check) {//已经无法很确切知道这里是要用checked还是check()从而导致逻辑错误\n            //do some thing\n        }\n        \n    \n    规范后代码\n    \n        var bChecked = false;\n        var fnCheck = function() {\n            return true;\n        }\n        /**\n        some code\n        **/\n        \n        if(bChecked) {\n            // do some thing\n        }\n        if(fnCheck()) {\n            // do other thing\n        }\n        \n    \n*   如何标明私有方法或私有属性？\n    \n        var person = {\n            getName: function () {\n                return this._getFirst() + ' ' + this._getLast();\n            },\n            _getFirst: function () {\n                //...\n            },\n            _getLast: function (){\n                //...\n            } };\n        \n    \n    在这个例子中，getName()以为这这是API的一个公开的方法，而\\_getFirst()和\\_getLast()意味着这是一个私有函数。尽管他们都是普通的公开方法，但是使用下划线前缀的表示方法可以提醒使用person对象的用户，告诉他们这些方法在其他地方不能确保一定能够正常工作，不能直接调用。\n    \n*   总结：下面是一些使用下划线约定的变量\n    \n    *   使用下划线结尾来表明是私有变量，例如name_和getElements_()。\n    *   使用一个下划线前缀来表示受保护属性，使用两个下划线前缀来表示私有属性。\n\n* * *\n\n四、编写注释\n------\n\n> 为代码编写注释是非常重要的。通常人们在深入思考一个问题时，会非常清楚这段代码的工作原理。但是当过一周后再次回到该代码时，可能会花上很长时间来回想起那段代码到底是干什么的。\n\n*   公共组件维护者和各栏目WD都需要在文件头部加上注释说明：\n    \n        /**\n        *文件用途说明\n        *作者姓名、联系方式（旺旺）\n        *制作日期\n        **/\n        \n    \n*   大的模块注释方法：\n    \n        //================\n        // 代码用途\n        //================\n        \n    \n*   小的注释；\n    \n        //代码说明\n        \n    \n    注释单独一行，不要在代码后的同一行内加注释。例如：\n    \n        //姓名\n        var name = “abc”;   V\n        var name =”abc”; //姓名 X\n        \n    \n\n* * *\n\n五、使用空格\n------\n\n> 使用空格有助于改善代码的可读性和一致性。在撰写英文文章时在逗号和区间范围后面使用空格。在javascript采用同样的逻辑，可在列表表达式（等价于逗号）和语句结束（等价于完成一次“思考”）后面添加空格。\n\n**用处一**\n\n*   在分开for循环的各个部分的分号之后：例如，for (var i = 0; i < 10; i +=1){…}\n*   在for循环中初始化多个变量（i和最大值等）：for (var i = 0, max = 10; i < max; i += 1){…}\n*   在限定数组项的逗号后面：var a = \\[1, 2, 3\\];\n*   对象属性的逗号之后和将属性名和属性值分开的冒号之后：var o = {a: 1, b: 2};\n*   分隔开函数中各个参数的逗号之后：myFunc(a, b, c)\n*   在函数声明的大括号之前：function myFunc() {}\n*   在匿名函数表达式之后：var myFunc = function () {};\n\n**用初二**\n\n空格的另外一个很好的用途是用来分隔所有的操作符和操作，这也就是意味着在 +, -, *, =, <, >, <=, >=, ===, !==, &&, ||, += 等之后使用空格：\n\n例子：\n\n    //大量空格，并且使用一致，是的代码可读性更好\n    //允许在阅读的时候不用一口气读下去\n    var d = 0,\n        a = b +1;\n    if ( a && b && c) {\n        d = a % c;\n        a += d;\n    }\n    \n    //反模式\n    //缺少空格或空格使用不一致，使得代码比较混乱\n    var d= 0;\n        a =b+1;\n    if (a&& b&& c) {\n    d=a %c;\n        a+= d;\n    }\n    \n\n* * *\n\n六、编写API文档\n---------\n\n### 1\\. 生成API文档的步骤：\n\n*   编写特殊格式的代码块（即一些注释块）\n*   运行工具来解析代码和注释（工具如：JSDoc Toolkit和YUIDoc）\n*   发布工具解析的结果，大多数情况是采用HTML格式发布（如网页版的API文档就是利用工具生成的）\n\n**简单举例**：\n\n    /**\n    * 翻转一个字符串\n    *\n    * @param  {String} 输入需要翻转的字符串\n    * @return {String} 翻转后的字符串\n    **/\n    \n    var reverse = function (input) {\n        //...\n        return output;\n    };\n    \n\n**YUIDoc范例**：\n\n> 完整范例：本程序由一个文件(app.js)组成，该文件仅有一个模块(myapp)。\n\napp.js:\n\n    /**\n    * 我的javascript应用程序\n    *\n    * @module myapp\n    */\n    \n    //使用命名空间来定义一个空对象\n    var MYAPP = {};\n    \n    //定义一个包含两个方法(sum()和multi())的math_stuff对象\n    /**\n    * @namespace MYAPP\n    * class math_stuff\n    */\n    \n    MYAPP.math_stuff = {\n        /**\n        * Sums two numbers\n        *\n        * @method sum\n        * param     {Number}    是第一个数\n        * param     {Number}    是第二个数\n        * return    {Number}    两个输入的总和\n        */\n        sum: function (a, b) {\n            return a + b;\n        },\n        /**\n        * Multiplies two numbers\n        * param     {Number}    是第一个数\n        * param     {Number}    是第二个数\n        * return    {Number}    两个输入相乘后结果\n        */\n        multi: function (a, b) {\n            return a * b;\n        }\n    };\n    \n\n@namespace：这里用于命名包含以上对象的全局引用的名称\n\n@class：这里有些命名不当，他实际意思是指对象或者构造函数\n\n@method：定义对象中的方法和方法名\n\n@param：列举函数所使用的参数。其中将参数类型用大括号括起来，并在其后注释参数名及描述。\n\n@return：类似于@param，这里用于描述返回值的，并且该方法没有名称。\n\n@constructor：表明这个“类”实际上是一个构造函数\n\n@property和@type描述了对象的属性。\n\n### 2\\. 编写API目的：\n\n*   为API编写注释不仅仅是一中提供参考文档的简便方法，而且还有其他用途——通过再次审查代码，提高代码质量。\n*   在解决问题时写出的解决方案仅仅是一个初稿。该解决方案可以给出令人期待的输出，但是该方案是否是最佳方案呢？改代码是否可读、易于理解、维护和升级呢？当您再次审视代码时您将更加确定代码哪些部分可以改进——如何使得代码更容易继续更新，移除一些不足之处等。它可以极大地帮助您创建高质量的代码。\n\n* * *\n\n七、推荐写法\n------\n\n1.  除了三目运算，if,else等禁止简写\n    \n         // 正确的书写\n         if (true) {\n             alert(name);\n         }\n         console.log(name);\n         // 不推荐的书写\n         if (true)\n             alert(name);\n         console.log(name);\n         // 不推荐的书写\n         if (true)\n         alert(name);\n         console.log(name)\n        \n    \n2.  在需要以{}闭合的代码段前增加换行，如：for if\n    \n         // 没有换行，小的代码段无法区分\n         if (wl && wl.length) {\n             for (i = 0, l = wl.length; i < l; ++i) {\n                 p = wl[i];\n                 type = Y.Lang.type(r[p]);\n                 if (s.hasOwnProperty(p)) {\n                     if (merge && type == 'object') {\n                         Y.mix(r[p], s[p]);\n                     } else if (ov || !(p in r)) {\n                         r[p] = s[p];\n                     }\n                 }\n             }\n         }\n         // 有了换行，逻辑清楚多了\n         if (wl && wl.length) {\n        \n             for (i = 0, l = wl.length; i < l; ++i) {\n                 p = wl[i];\n                 type = Y.Lang.type(r[p]);\n        \n                 if (s.hasOwnProperty(p)) {\n                     // 处理merge逻辑\n                     if (merge && type == 'object') {\n                         Y.mix(r[p], s[p]);\n                     } else if (ov || !(p in r)) {\n                         r[p] = s[p];\n                     }\n                 }\n             }\n         }\n        换行可以是空行，也可以是注释\n        \n    \n3.  使用Function进行类的定义，不推荐继承，如需继承采用成熟的类库实现继承\n    \n        // 类的实现\n         function Person(name) {\n             this.name = name;\n         }\n        \n         Person.prototype.sayName = function() {\n             alert(this.name);\n         };\n        \n         var me = new Person(\"Nicholas\");\n        \n         // 将this放到局部变量self\n         function Persion(name, sex) {\n             var self = this;\n        \n             self.name = name;\n             self.sex = sex;\n         }\n        \n    \n    平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点：\n    \n        function A(){\n            //...\n        }\n        function B(){\n            //...\n        }\n        B.prototype = new A();\n        B.prototype.constructor = B; //原则上，记得把这句话加上\n        \n    \n    继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~\n    \n4.  使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象)\n    \n        // 缓存对象\n        var getComment = function() {\n            var dom = $(\"#common-container\"),               // 缓存dom\n                        appendTo = $.appendTo,                      // 缓存全局变量\n                data = this.json.data;                      // 缓存作用域链较深的对象\n        }\n        \n        \n        //当需要缓存this时必须使用self变量进行缓存\n        // 缓存this\n        function Row(name) {\n            var self = this;\n        \n            self.name = name;\n            $(\".row\").click(function() {\n                self.getName();\n            });\n        }\n        \n    \n    self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。\n    \n5.  使用eval，采取$.parseJSON\n    \n    三个原因：\n    \n    *   有注入风险，尤其是ajax返回数据\n    *   不方便debug\n    *   效率低，eval是一个执行效率很低的函数\n    \n    建议： 使用new Function来代替eval的使用，最好就别用。\n    \n\n* * *\n\n八、不规范写法\n-------\n\n1.  句尾没有分号\n    \n        var isHotel = json.type == \"hotel\" ? true : false\n        \n    \n    这个是要引起注意的，比如：\n    \n        a = b        // 赋值\n        (function(){\n            //....\n        })()         // 自执行函数\n        \n    \n    未加分号，结果被解析成\n    \n        a = b(function(){//...})()  //将b()()返回的结果赋值给a\n        \n    \n2.  变量命名各种各样\n    \n        var is_hotel;\n        var isHotel;\n        var ishotel;\n        \n    \n3.  if 缩写\n    \n        if (isHotel)\n            console.log(true)\n        else\n            console.log(false)\n        \n    \n4.  使用 eval\n    \n        var json = eval(jsonText);\n        \n    \n5.  变量未定义到处都是\n    \n        function() {\n            var isHotel = 'true';\n            .......\n        \n            var html = isHotel ? '<p>hotel</p>' : \"\";\n        }\n        \n    \n6.  超长函数\n    \n        function() {\n            var isHotel = 'true';\n            //....... 此处省略500行\n            return false;\n        }\n        \n    \n\n* * *\n\n九、需要注意的地方\n---------\n\n1.  window.onload只能使用一次，使用多次会被最后的覆盖。\n    \n    解决方案：\n    \n    *   只引用一次window.onload\n    *   使用jQuery的$(docuemnt.ready(function(){}); 可多次使用\n    *   使用函数封装，代码地址\n2.  CSS放在页头引入，javascript放在页尾引入\n    \n3.  在上线之前，要编译压缩代码\n4.  减少重排与重绘\n\n* * *","source":"_posts/前端规范-dya03.md","raw":"---\ntitle:  前端JS规范文档\ndate: 2018-05-12 18:34:20\ntags: \n    - 前端规范\ncover: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556021977157&di=ca5a227f59250179324d49264938cfc7&imgtype=0&src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F591245435ade8c91e3e22e90d23d80b8.jpeg\ncategories: \n    - 大杂烩\n---\n\n### 目录导航\n\n*   [前端javascript规范文档](#前端javascript规范文档)\n    *   [一、规范目的](#一规范目的)\n    *   [二、基本准则](#二基本准则)\n    *   [三、命名规范](#三命名规范)\n        *   [1\\. 目的](#目的)\n        *   [2\\. 变量名](#变量名)\n        *   [3\\. 构造函数（类）命名](#构造函数类命名)\n        *   [4\\. 普通变量命名](#普通变量命名)\n        *   [5\\. 匈牙利命名法](#匈牙利命名法)\n        *   [6\\. 其他前缀规范](#其他前缀规范)\n        *   [7\\. 例外情况](#例外情况)\n        *   [8\\. 函数命名](#函数命名)\n        *   [9\\. 变量命名例子](#变量命名例子)\n    *   [四、编写注释](#四编写注释)\n    *   [五、使用空格](#五使用空格)\n    *   [六、编写API文档](#六编写api文档)\n        *   [1\\. 生成API文档的步骤：](#生成api文档的步骤)\n        *   [2\\. 编写API目的：](#编写api目的)\n    *   [七、推荐写法](#七推荐写法)\n    *   [八、不规范写法](#八不规范写法)\n    *   [九、需要注意的地方](#九需要注意的地方)\n    *   [十、扩展阅读：](#十扩展阅读)\n\n前端javascript规范文档\n================\n\n> 说明：本文档为前端JS规范\n\n* * *\n\n一、规范目的\n------\n\n为提高团队协作效率，便于前端后期优化维护，输出高质量的文档。\n\n* * *\n\n二、基本准则\n------\n\n*   符合web标准，结构表现行为分离，兼容性优良。页面性能方面，代码要求简洁明了有序， 尽可能的减小服务器负载，保证最快的解析速度。\n*   项目的维护和二次开发可能是直接或间接的团队合作，所以创建易维护的代码是一个项目成功与否的关键，易维护的代码意味着具有如下特性：\n    *   阅读性好：如良好的注释和命名规范，有文档\n    *   具有一致性：看起来如同一个人编写\n    *   代码的松耦合，高度模块化：将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从html,css,js三个层面都要考虑模块化\n    *   严格按照规范编写代码\n\n* * *\n\n三、命名规范\n------\n\n### 1\\. 目的\n\n提高代码可预测性和可维护性的方法是使用命名约定，这就意味着采用一致的方法来对变量和函数进行命名。\n\n### 2\\. 变量名\n\n变量名包括全局变量，局部变量，类变量，函数参数\n\n### 3\\. 构造函数（类）命名\n\n首字母大写，驼峰式命名。\n\nJS中没有类，但是可以用new调用构造函数：var man = new Person();\n\n### 4\\. 普通变量命名\n\n首字母小写，驼峰式命名，匈牙利命名\n\n如：nCheckCount 表示整形的数值\n\n### 5\\. 匈牙利命名法\n\n匈牙利命名法语法：变量名＝类型＋对象描述\n\n*   类型指变量的类型\n*   对象描述指对象名字全称或名字的一部分，要求有明确含义，命名要容易记忆容易理解。\n\n**提示**: 虽然JavaScript变量表面上没有类型，但是JavaScript内部还是会为变量赋予相应的类型\n\nJavaScript变量起名类型\n\n变量命名前缀\n\n举例\n\nArray 数组\n\na\n\naList，aGroup\n\nBoolean 逻辑\n\nb\n\nbChecked，bHasLogin\n\nFunction 函数\n\nf\n\nfGetHtml，fInit\n\nInteger 数字\n\nn\n\nnPage，nTotal\n\nObject 对象\n\no\n\noButton，oDate\n\nRegular Expression 正则\n\nr\n\nrDomain，rEmail\n\nString 字符\n\ns\n\nsName，sHtml\n\n### 6\\. 其他前缀规范\n\n可根据团队及项目需要增加\n\n*   $：表示Jquery对象\n    \n    例如：$Content，$Module，一种比较广泛的Jquery对象变量命名规范。\n    \n*   fn：表示函数\n    \n    例如：fnGetName，fnSetAge；和上面函数的前缀略有不同，改用fn来代替，个人认为fn能够更好的区分普通变量和函数变量。\n    \n\n### 7\\. 例外情况\n\n以根据项目及团队需要，设计出针对项目需要的前缀规范，从而达到团队开发协作便利的目的。\n\n*   作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr。\n*   循环变量可以简写，比如：i，j，k等。\n*   某些作为不允许修改值的变量认为是常量，全部字母都大写。例如：COPYRIGHT，PI。常量可以存在于函数中，也可以存在于全局。必须采用全大写的命名，且单词以_分割，常量通常用于ajax请求url，和一些不会改变的数据。\n\n### 8\\. 函数命名\n\n**普通函数**：首字母小写，驼峰式命名，统一使用动词或者动词+名词形式\n\n例如：fnGetVersion()，fnSubmitForm()，fnInit()；涉及返回逻辑值的函数可以使用is，has，contains等表示逻辑的词语代替动词，例如：fnIsObject()，fnHasClass()，fnContainsElment()。\n\n**内部函数**：使用_fn+动词+名词形式，内部函数必需在函数最后定义。\n\n例如：\n\n    function fnGetNumber(nTotal) {\n        if (nTotal < 100) {\n            nTotal = 100;\n        }\n        return _fnAdd(nTotal);\n    \n        function _fnAdd(nNumber) {\n            nNumber++;\n            return nNumber;\n        }\n    }\n    alert(fGetNumber(10)); //alert 101\n    \n\n**对象方法与事件响应函数**：对象方法命名使用fn+对象类名+动词+名词形式；\n\n例如： fnAddressGetEmail()，\n\n**事件响应函数**：fn+触发事件对象名+事件名或者模块名\n\n例如：fnDivClick()，fnAddressSubmitButtonClick()\n\n**函数方法常用的动词**：\n\n    get 获取/set 设置,\n    add 增加/remove 删除\n    create 创建/destory 移除\n    start 启动/stop 停止\n    open 打开/close 关闭,\n    read 读取/write 写入\n    load 载入/save 保存,\n    create 创建/destroy 销毁\n    begin 开始/end 结束,\n    backup 备份/restore 恢复\n    import 导入/export 导出,\n    split 分割/merge 合并\n    inject 注入/extract 提取,\n    attach 附着/detach 脱离\n    bind 绑定/separate 分离,\n    view 查看/browse 浏览\n    edit 编辑/modify 修改,\n    select 选取/mark 标记\n    copy 复制/paste 粘贴,\n    undo 撤销/redo 重做\n    insert 插入/delete 移除,\n    add 加入/append 添加\n    clean 清理/clear 清除,\n    index 索引/sort 排序\n    find 查找/search 搜索,\n    increase 增加/decrease 减少\n    play 播放/pause 暂停,\n    launch 启动/run 运行\n    compile 编译/execute 执行,\n    debug 调试/trace 跟踪\n    observe 观察/listen 监听,\n    build 构建/publish 发布\n    input 输入/output 输出,\n    encode 编码/decode 解码\n    encrypt 加密/decrypt 解密,\n    compress 压缩/decompress 解压缩\n    pack 打包/unpack 解包,\n    parse 解析/emit 生成\n    connect 连接/disconnect 断开,\n    send 发送/receive 接收\n    download 下载/upload 上传,\n    refresh 刷新/synchronize 同步\n    update 更新/revert 复原,\n    lock 锁定/unlock 解锁\n    check out 签出/check in 签入,\n    submit 提交/commit 交付\n    push 推/pull 拉,\n    expand 展开/collapse 折叠\n    begin 起始/end 结束,\n    start 开始/finish 完成\n    enter 进入/exit 退出,\n    abort 放弃/quit 离开\n    obsolete 废弃/depreciate 废旧,\n    collect 收集/aggregate 聚集\n    \n\n### 9\\. 变量命名例子\n\n*   为什么需要这样强制定义变量前缀？正式因为javascript是弱语言造成的。在定义大量变量的时候，我们需要很明确的知道当前变量是什么属性，如果只通过普通单词，是很难区分的。\n    \n    普通代码\n    \n        var checked = false;\n        var check = function() {\n            return true;\n        }\n        /**\n        some code\n        **/\n        \n        if(check) {//已经无法很确切知道这里是要用checked还是check()从而导致逻辑错误\n            //do some thing\n        }\n        \n    \n    规范后代码\n    \n        var bChecked = false;\n        var fnCheck = function() {\n            return true;\n        }\n        /**\n        some code\n        **/\n        \n        if(bChecked) {\n            // do some thing\n        }\n        if(fnCheck()) {\n            // do other thing\n        }\n        \n    \n*   如何标明私有方法或私有属性？\n    \n        var person = {\n            getName: function () {\n                return this._getFirst() + ' ' + this._getLast();\n            },\n            _getFirst: function () {\n                //...\n            },\n            _getLast: function (){\n                //...\n            } };\n        \n    \n    在这个例子中，getName()以为这这是API的一个公开的方法，而\\_getFirst()和\\_getLast()意味着这是一个私有函数。尽管他们都是普通的公开方法，但是使用下划线前缀的表示方法可以提醒使用person对象的用户，告诉他们这些方法在其他地方不能确保一定能够正常工作，不能直接调用。\n    \n*   总结：下面是一些使用下划线约定的变量\n    \n    *   使用下划线结尾来表明是私有变量，例如name_和getElements_()。\n    *   使用一个下划线前缀来表示受保护属性，使用两个下划线前缀来表示私有属性。\n\n* * *\n\n四、编写注释\n------\n\n> 为代码编写注释是非常重要的。通常人们在深入思考一个问题时，会非常清楚这段代码的工作原理。但是当过一周后再次回到该代码时，可能会花上很长时间来回想起那段代码到底是干什么的。\n\n*   公共组件维护者和各栏目WD都需要在文件头部加上注释说明：\n    \n        /**\n        *文件用途说明\n        *作者姓名、联系方式（旺旺）\n        *制作日期\n        **/\n        \n    \n*   大的模块注释方法：\n    \n        //================\n        // 代码用途\n        //================\n        \n    \n*   小的注释；\n    \n        //代码说明\n        \n    \n    注释单独一行，不要在代码后的同一行内加注释。例如：\n    \n        //姓名\n        var name = “abc”;   V\n        var name =”abc”; //姓名 X\n        \n    \n\n* * *\n\n五、使用空格\n------\n\n> 使用空格有助于改善代码的可读性和一致性。在撰写英文文章时在逗号和区间范围后面使用空格。在javascript采用同样的逻辑，可在列表表达式（等价于逗号）和语句结束（等价于完成一次“思考”）后面添加空格。\n\n**用处一**\n\n*   在分开for循环的各个部分的分号之后：例如，for (var i = 0; i < 10; i +=1){…}\n*   在for循环中初始化多个变量（i和最大值等）：for (var i = 0, max = 10; i < max; i += 1){…}\n*   在限定数组项的逗号后面：var a = \\[1, 2, 3\\];\n*   对象属性的逗号之后和将属性名和属性值分开的冒号之后：var o = {a: 1, b: 2};\n*   分隔开函数中各个参数的逗号之后：myFunc(a, b, c)\n*   在函数声明的大括号之前：function myFunc() {}\n*   在匿名函数表达式之后：var myFunc = function () {};\n\n**用初二**\n\n空格的另外一个很好的用途是用来分隔所有的操作符和操作，这也就是意味着在 +, -, *, =, <, >, <=, >=, ===, !==, &&, ||, += 等之后使用空格：\n\n例子：\n\n    //大量空格，并且使用一致，是的代码可读性更好\n    //允许在阅读的时候不用一口气读下去\n    var d = 0,\n        a = b +1;\n    if ( a && b && c) {\n        d = a % c;\n        a += d;\n    }\n    \n    //反模式\n    //缺少空格或空格使用不一致，使得代码比较混乱\n    var d= 0;\n        a =b+1;\n    if (a&& b&& c) {\n    d=a %c;\n        a+= d;\n    }\n    \n\n* * *\n\n六、编写API文档\n---------\n\n### 1\\. 生成API文档的步骤：\n\n*   编写特殊格式的代码块（即一些注释块）\n*   运行工具来解析代码和注释（工具如：JSDoc Toolkit和YUIDoc）\n*   发布工具解析的结果，大多数情况是采用HTML格式发布（如网页版的API文档就是利用工具生成的）\n\n**简单举例**：\n\n    /**\n    * 翻转一个字符串\n    *\n    * @param  {String} 输入需要翻转的字符串\n    * @return {String} 翻转后的字符串\n    **/\n    \n    var reverse = function (input) {\n        //...\n        return output;\n    };\n    \n\n**YUIDoc范例**：\n\n> 完整范例：本程序由一个文件(app.js)组成，该文件仅有一个模块(myapp)。\n\napp.js:\n\n    /**\n    * 我的javascript应用程序\n    *\n    * @module myapp\n    */\n    \n    //使用命名空间来定义一个空对象\n    var MYAPP = {};\n    \n    //定义一个包含两个方法(sum()和multi())的math_stuff对象\n    /**\n    * @namespace MYAPP\n    * class math_stuff\n    */\n    \n    MYAPP.math_stuff = {\n        /**\n        * Sums two numbers\n        *\n        * @method sum\n        * param     {Number}    是第一个数\n        * param     {Number}    是第二个数\n        * return    {Number}    两个输入的总和\n        */\n        sum: function (a, b) {\n            return a + b;\n        },\n        /**\n        * Multiplies two numbers\n        * param     {Number}    是第一个数\n        * param     {Number}    是第二个数\n        * return    {Number}    两个输入相乘后结果\n        */\n        multi: function (a, b) {\n            return a * b;\n        }\n    };\n    \n\n@namespace：这里用于命名包含以上对象的全局引用的名称\n\n@class：这里有些命名不当，他实际意思是指对象或者构造函数\n\n@method：定义对象中的方法和方法名\n\n@param：列举函数所使用的参数。其中将参数类型用大括号括起来，并在其后注释参数名及描述。\n\n@return：类似于@param，这里用于描述返回值的，并且该方法没有名称。\n\n@constructor：表明这个“类”实际上是一个构造函数\n\n@property和@type描述了对象的属性。\n\n### 2\\. 编写API目的：\n\n*   为API编写注释不仅仅是一中提供参考文档的简便方法，而且还有其他用途——通过再次审查代码，提高代码质量。\n*   在解决问题时写出的解决方案仅仅是一个初稿。该解决方案可以给出令人期待的输出，但是该方案是否是最佳方案呢？改代码是否可读、易于理解、维护和升级呢？当您再次审视代码时您将更加确定代码哪些部分可以改进——如何使得代码更容易继续更新，移除一些不足之处等。它可以极大地帮助您创建高质量的代码。\n\n* * *\n\n七、推荐写法\n------\n\n1.  除了三目运算，if,else等禁止简写\n    \n         // 正确的书写\n         if (true) {\n             alert(name);\n         }\n         console.log(name);\n         // 不推荐的书写\n         if (true)\n             alert(name);\n         console.log(name);\n         // 不推荐的书写\n         if (true)\n         alert(name);\n         console.log(name)\n        \n    \n2.  在需要以{}闭合的代码段前增加换行，如：for if\n    \n         // 没有换行，小的代码段无法区分\n         if (wl && wl.length) {\n             for (i = 0, l = wl.length; i < l; ++i) {\n                 p = wl[i];\n                 type = Y.Lang.type(r[p]);\n                 if (s.hasOwnProperty(p)) {\n                     if (merge && type == 'object') {\n                         Y.mix(r[p], s[p]);\n                     } else if (ov || !(p in r)) {\n                         r[p] = s[p];\n                     }\n                 }\n             }\n         }\n         // 有了换行，逻辑清楚多了\n         if (wl && wl.length) {\n        \n             for (i = 0, l = wl.length; i < l; ++i) {\n                 p = wl[i];\n                 type = Y.Lang.type(r[p]);\n        \n                 if (s.hasOwnProperty(p)) {\n                     // 处理merge逻辑\n                     if (merge && type == 'object') {\n                         Y.mix(r[p], s[p]);\n                     } else if (ov || !(p in r)) {\n                         r[p] = s[p];\n                     }\n                 }\n             }\n         }\n        换行可以是空行，也可以是注释\n        \n    \n3.  使用Function进行类的定义，不推荐继承，如需继承采用成熟的类库实现继承\n    \n        // 类的实现\n         function Person(name) {\n             this.name = name;\n         }\n        \n         Person.prototype.sayName = function() {\n             alert(this.name);\n         };\n        \n         var me = new Person(\"Nicholas\");\n        \n         // 将this放到局部变量self\n         function Persion(name, sex) {\n             var self = this;\n        \n             self.name = name;\n             self.sex = sex;\n         }\n        \n    \n    平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点：\n    \n        function A(){\n            //...\n        }\n        function B(){\n            //...\n        }\n        B.prototype = new A();\n        B.prototype.constructor = B; //原则上，记得把这句话加上\n        \n    \n    继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~\n    \n4.  使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象)\n    \n        // 缓存对象\n        var getComment = function() {\n            var dom = $(\"#common-container\"),               // 缓存dom\n                        appendTo = $.appendTo,                      // 缓存全局变量\n                data = this.json.data;                      // 缓存作用域链较深的对象\n        }\n        \n        \n        //当需要缓存this时必须使用self变量进行缓存\n        // 缓存this\n        function Row(name) {\n            var self = this;\n        \n            self.name = name;\n            $(\".row\").click(function() {\n                self.getName();\n            });\n        }\n        \n    \n    self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。\n    \n5.  使用eval，采取$.parseJSON\n    \n    三个原因：\n    \n    *   有注入风险，尤其是ajax返回数据\n    *   不方便debug\n    *   效率低，eval是一个执行效率很低的函数\n    \n    建议： 使用new Function来代替eval的使用，最好就别用。\n    \n\n* * *\n\n八、不规范写法\n-------\n\n1.  句尾没有分号\n    \n        var isHotel = json.type == \"hotel\" ? true : false\n        \n    \n    这个是要引起注意的，比如：\n    \n        a = b        // 赋值\n        (function(){\n            //....\n        })()         // 自执行函数\n        \n    \n    未加分号，结果被解析成\n    \n        a = b(function(){//...})()  //将b()()返回的结果赋值给a\n        \n    \n2.  变量命名各种各样\n    \n        var is_hotel;\n        var isHotel;\n        var ishotel;\n        \n    \n3.  if 缩写\n    \n        if (isHotel)\n            console.log(true)\n        else\n            console.log(false)\n        \n    \n4.  使用 eval\n    \n        var json = eval(jsonText);\n        \n    \n5.  变量未定义到处都是\n    \n        function() {\n            var isHotel = 'true';\n            .......\n        \n            var html = isHotel ? '<p>hotel</p>' : \"\";\n        }\n        \n    \n6.  超长函数\n    \n        function() {\n            var isHotel = 'true';\n            //....... 此处省略500行\n            return false;\n        }\n        \n    \n\n* * *\n\n九、需要注意的地方\n---------\n\n1.  window.onload只能使用一次，使用多次会被最后的覆盖。\n    \n    解决方案：\n    \n    *   只引用一次window.onload\n    *   使用jQuery的$(docuemnt.ready(function(){}); 可多次使用\n    *   使用函数封装，代码地址\n2.  CSS放在页头引入，javascript放在页尾引入\n    \n3.  在上线之前，要编译压缩代码\n4.  减少重排与重绘\n\n* * *","slug":"前端规范-dya03","published":1,"updated":"2019-04-23T09:41:52.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjutlylg20006zcums3pisutr","content":"<h3 id=\"目录导航\"><a href=\"#目录导航\" class=\"headerlink\" title=\"目录导航\"></a>目录导航</h3><ul>\n<li><a href=\"#前端javascript规范文档\">前端javascript规范文档</a><ul>\n<li><a href=\"#一规范目的\">一、规范目的</a></li>\n<li><a href=\"#二基本准则\">二、基本准则</a></li>\n<li><a href=\"#三命名规范\">三、命名规范</a><ul>\n<li><a href=\"#目的\">1. 目的</a></li>\n<li><a href=\"#变量名\">2. 变量名</a></li>\n<li><a href=\"#构造函数类命名\">3. 构造函数（类）命名</a></li>\n<li><a href=\"#普通变量命名\">4. 普通变量命名</a></li>\n<li><a href=\"#匈牙利命名法\">5. 匈牙利命名法</a></li>\n<li><a href=\"#其他前缀规范\">6. 其他前缀规范</a></li>\n<li><a href=\"#例外情况\">7. 例外情况</a></li>\n<li><a href=\"#函数命名\">8. 函数命名</a></li>\n<li><a href=\"#变量命名例子\">9. 变量命名例子</a></li>\n</ul>\n</li>\n<li><a href=\"#四编写注释\">四、编写注释</a></li>\n<li><a href=\"#五使用空格\">五、使用空格</a></li>\n<li><a href=\"#六编写api文档\">六、编写API文档</a><ul>\n<li><a href=\"#生成api文档的步骤\">1. 生成API文档的步骤：</a></li>\n<li><a href=\"#编写api目的\">2. 编写API目的：</a></li>\n</ul>\n</li>\n<li><a href=\"#七推荐写法\">七、推荐写法</a></li>\n<li><a href=\"#八不规范写法\">八、不规范写法</a></li>\n<li><a href=\"#九需要注意的地方\">九、需要注意的地方</a></li>\n<li><a href=\"#十扩展阅读\">十、扩展阅读：</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"前端javascript规范文档\"><a href=\"#前端javascript规范文档\" class=\"headerlink\" title=\"前端javascript规范文档\"></a>前端javascript规范文档</h1><blockquote>\n<p>说明：本文档为前端JS规范</p>\n</blockquote>\n<hr>\n<h2 id=\"一、规范目的\"><a href=\"#一、规范目的\" class=\"headerlink\" title=\"一、规范目的\"></a>一、规范目的</h2><p>为提高团队协作效率，便于前端后期优化维护，输出高质量的文档。</p>\n<hr>\n<h2 id=\"二、基本准则\"><a href=\"#二、基本准则\" class=\"headerlink\" title=\"二、基本准则\"></a>二、基本准则</h2><ul>\n<li>符合web标准，结构表现行为分离，兼容性优良。页面性能方面，代码要求简洁明了有序， 尽可能的减小服务器负载，保证最快的解析速度。</li>\n<li>项目的维护和二次开发可能是直接或间接的团队合作，所以创建易维护的代码是一个项目成功与否的关键，易维护的代码意味着具有如下特性：<ul>\n<li>阅读性好：如良好的注释和命名规范，有文档</li>\n<li>具有一致性：看起来如同一个人编写</li>\n<li>代码的松耦合，高度模块化：将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从html,css,js三个层面都要考虑模块化</li>\n<li>严格按照规范编写代码</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"三、命名规范\"><a href=\"#三、命名规范\" class=\"headerlink\" title=\"三、命名规范\"></a>三、命名规范</h2><h3 id=\"1-目的\"><a href=\"#1-目的\" class=\"headerlink\" title=\"1. 目的\"></a>1. 目的</h3><p>提高代码可预测性和可维护性的方法是使用命名约定，这就意味着采用一致的方法来对变量和函数进行命名。</p>\n<h3 id=\"2-变量名\"><a href=\"#2-变量名\" class=\"headerlink\" title=\"2. 变量名\"></a>2. 变量名</h3><p>变量名包括全局变量，局部变量，类变量，函数参数</p>\n<h3 id=\"3-构造函数（类）命名\"><a href=\"#3-构造函数（类）命名\" class=\"headerlink\" title=\"3. 构造函数（类）命名\"></a>3. 构造函数（类）命名</h3><p>首字母大写，驼峰式命名。</p>\n<p>JS中没有类，但是可以用new调用构造函数：var man = new Person();</p>\n<h3 id=\"4-普通变量命名\"><a href=\"#4-普通变量命名\" class=\"headerlink\" title=\"4. 普通变量命名\"></a>4. 普通变量命名</h3><p>首字母小写，驼峰式命名，匈牙利命名</p>\n<p>如：nCheckCount 表示整形的数值</p>\n<h3 id=\"5-匈牙利命名法\"><a href=\"#5-匈牙利命名法\" class=\"headerlink\" title=\"5. 匈牙利命名法\"></a>5. 匈牙利命名法</h3><p>匈牙利命名法语法：变量名＝类型＋对象描述</p>\n<ul>\n<li>类型指变量的类型</li>\n<li>对象描述指对象名字全称或名字的一部分，要求有明确含义，命名要容易记忆容易理解。</li>\n</ul>\n<p><strong>提示</strong>: 虽然JavaScript变量表面上没有类型，但是JavaScript内部还是会为变量赋予相应的类型</p>\n<p>JavaScript变量起名类型</p>\n<p>变量命名前缀</p>\n<p>举例</p>\n<p>Array 数组</p>\n<p>a</p>\n<p>aList，aGroup</p>\n<p>Boolean 逻辑</p>\n<p>b</p>\n<p>bChecked，bHasLogin</p>\n<p>Function 函数</p>\n<p>f</p>\n<p>fGetHtml，fInit</p>\n<p>Integer 数字</p>\n<p>n</p>\n<p>nPage，nTotal</p>\n<p>Object 对象</p>\n<p>o</p>\n<p>oButton，oDate</p>\n<p>Regular Expression 正则</p>\n<p>r</p>\n<p>rDomain，rEmail</p>\n<p>String 字符</p>\n<p>s</p>\n<p>sName，sHtml</p>\n<h3 id=\"6-其他前缀规范\"><a href=\"#6-其他前缀规范\" class=\"headerlink\" title=\"6. 其他前缀规范\"></a>6. 其他前缀规范</h3><p>可根据团队及项目需要增加</p>\n<ul>\n<li><p>$：表示Jquery对象</p>\n<p>例如：$Content，$Module，一种比较广泛的Jquery对象变量命名规范。</p>\n</li>\n<li><p>fn：表示函数</p>\n<p>例如：fnGetName，fnSetAge；和上面函数的前缀略有不同，改用fn来代替，个人认为fn能够更好的区分普通变量和函数变量。</p>\n</li>\n</ul>\n<h3 id=\"7-例外情况\"><a href=\"#7-例外情况\" class=\"headerlink\" title=\"7. 例外情况\"></a>7. 例外情况</h3><p>以根据项目及团队需要，设计出针对项目需要的前缀规范，从而达到团队开发协作便利的目的。</p>\n<ul>\n<li>作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr。</li>\n<li>循环变量可以简写，比如：i，j，k等。</li>\n<li>某些作为不允许修改值的变量认为是常量，全部字母都大写。例如：COPYRIGHT，PI。常量可以存在于函数中，也可以存在于全局。必须采用全大写的命名，且单词以_分割，常量通常用于ajax请求url，和一些不会改变的数据。</li>\n</ul>\n<h3 id=\"8-函数命名\"><a href=\"#8-函数命名\" class=\"headerlink\" title=\"8. 函数命名\"></a>8. 函数命名</h3><p><strong>普通函数</strong>：首字母小写，驼峰式命名，统一使用动词或者动词+名词形式</p>\n<p>例如：fnGetVersion()，fnSubmitForm()，fnInit()；涉及返回逻辑值的函数可以使用is，has，contains等表示逻辑的词语代替动词，例如：fnIsObject()，fnHasClass()，fnContainsElment()。</p>\n<p><strong>内部函数</strong>：使用_fn+动词+名词形式，内部函数必需在函数最后定义。</p>\n<p>例如：</p>\n<pre><code>function fnGetNumber(nTotal) {\n    if (nTotal &lt; 100) {\n        nTotal = 100;\n    }\n    return _fnAdd(nTotal);\n\n    function _fnAdd(nNumber) {\n        nNumber++;\n        return nNumber;\n    }\n}\nalert(fGetNumber(10)); //alert 101\n</code></pre><p><strong>对象方法与事件响应函数</strong>：对象方法命名使用fn+对象类名+动词+名词形式；</p>\n<p>例如： fnAddressGetEmail()，</p>\n<p><strong>事件响应函数</strong>：fn+触发事件对象名+事件名或者模块名</p>\n<p>例如：fnDivClick()，fnAddressSubmitButtonClick()</p>\n<p><strong>函数方法常用的动词</strong>：</p>\n<pre><code>get 获取/set 设置,\nadd 增加/remove 删除\ncreate 创建/destory 移除\nstart 启动/stop 停止\nopen 打开/close 关闭,\nread 读取/write 写入\nload 载入/save 保存,\ncreate 创建/destroy 销毁\nbegin 开始/end 结束,\nbackup 备份/restore 恢复\nimport 导入/export 导出,\nsplit 分割/merge 合并\ninject 注入/extract 提取,\nattach 附着/detach 脱离\nbind 绑定/separate 分离,\nview 查看/browse 浏览\nedit 编辑/modify 修改,\nselect 选取/mark 标记\ncopy 复制/paste 粘贴,\nundo 撤销/redo 重做\ninsert 插入/delete 移除,\nadd 加入/append 添加\nclean 清理/clear 清除,\nindex 索引/sort 排序\nfind 查找/search 搜索,\nincrease 增加/decrease 减少\nplay 播放/pause 暂停,\nlaunch 启动/run 运行\ncompile 编译/execute 执行,\ndebug 调试/trace 跟踪\nobserve 观察/listen 监听,\nbuild 构建/publish 发布\ninput 输入/output 输出,\nencode 编码/decode 解码\nencrypt 加密/decrypt 解密,\ncompress 压缩/decompress 解压缩\npack 打包/unpack 解包,\nparse 解析/emit 生成\nconnect 连接/disconnect 断开,\nsend 发送/receive 接收\ndownload 下载/upload 上传,\nrefresh 刷新/synchronize 同步\nupdate 更新/revert 复原,\nlock 锁定/unlock 解锁\ncheck out 签出/check in 签入,\nsubmit 提交/commit 交付\npush 推/pull 拉,\nexpand 展开/collapse 折叠\nbegin 起始/end 结束,\nstart 开始/finish 完成\nenter 进入/exit 退出,\nabort 放弃/quit 离开\nobsolete 废弃/depreciate 废旧,\ncollect 收集/aggregate 聚集\n</code></pre><h3 id=\"9-变量命名例子\"><a href=\"#9-变量命名例子\" class=\"headerlink\" title=\"9. 变量命名例子\"></a>9. 变量命名例子</h3><ul>\n<li><p>为什么需要这样强制定义变量前缀？正式因为javascript是弱语言造成的。在定义大量变量的时候，我们需要很明确的知道当前变量是什么属性，如果只通过普通单词，是很难区分的。</p>\n<p>普通代码</p>\n<pre><code>var checked = false;\nvar check = function() {\n    return true;\n}\n/**\nsome code\n**/\n\nif(check) {//已经无法很确切知道这里是要用checked还是check()从而导致逻辑错误\n    //do some thing\n}\n</code></pre></li>\n</ul>\n<pre><code>规范后代码\n\n    var bChecked = false;\n    var fnCheck = function() {\n        return true;\n    }\n    /**\n    some code\n    **/\n\n    if(bChecked) {\n        // do some thing\n    }\n    if(fnCheck()) {\n        // do other thing\n    }\n</code></pre><ul>\n<li><p>如何标明私有方法或私有属性？</p>\n<pre><code>var person = {\n    getName: function () {\n        return this._getFirst() + &apos; &apos; + this._getLast();\n    },\n    _getFirst: function () {\n        //...\n    },\n    _getLast: function (){\n        //...\n    } };\n</code></pre></li>\n</ul>\n<pre><code>在这个例子中，getName()以为这这是API的一个公开的方法，而\\_getFirst()和\\_getLast()意味着这是一个私有函数。尽管他们都是普通的公开方法，但是使用下划线前缀的表示方法可以提醒使用person对象的用户，告诉他们这些方法在其他地方不能确保一定能够正常工作，不能直接调用。\n</code></pre><ul>\n<li><p>总结：下面是一些使用下划线约定的变量</p>\n<ul>\n<li>使用下划线结尾来表明是私有变量，例如name_和getElements_()。</li>\n<li>使用一个下划线前缀来表示受保护属性，使用两个下划线前缀来表示私有属性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"四、编写注释\"><a href=\"#四、编写注释\" class=\"headerlink\" title=\"四、编写注释\"></a>四、编写注释</h2><blockquote>\n<p>为代码编写注释是非常重要的。通常人们在深入思考一个问题时，会非常清楚这段代码的工作原理。但是当过一周后再次回到该代码时，可能会花上很长时间来回想起那段代码到底是干什么的。</p>\n</blockquote>\n<ul>\n<li><p>公共组件维护者和各栏目WD都需要在文件头部加上注释说明：</p>\n<pre><code>/**\n*文件用途说明\n*作者姓名、联系方式（旺旺）\n*制作日期\n**/\n</code></pre></li>\n</ul>\n<ul>\n<li><p>大的模块注释方法：</p>\n<pre><code>//================\n// 代码用途\n//================\n</code></pre></li>\n</ul>\n<ul>\n<li><p>小的注释；</p>\n<pre><code>//代码说明\n</code></pre></li>\n</ul>\n<pre><code>注释单独一行，不要在代码后的同一行内加注释。例如：\n\n    //姓名\n    var name = “abc”;   V\n    var name =”abc”; //姓名 X\n</code></pre><hr>\n<h2 id=\"五、使用空格\"><a href=\"#五、使用空格\" class=\"headerlink\" title=\"五、使用空格\"></a>五、使用空格</h2><blockquote>\n<p>使用空格有助于改善代码的可读性和一致性。在撰写英文文章时在逗号和区间范围后面使用空格。在javascript采用同样的逻辑，可在列表表达式（等价于逗号）和语句结束（等价于完成一次“思考”）后面添加空格。</p>\n</blockquote>\n<p><strong>用处一</strong></p>\n<ul>\n<li>在分开for循环的各个部分的分号之后：例如，for (var i = 0; i &lt; 10; i +=1){…}</li>\n<li>在for循环中初始化多个变量（i和最大值等）：for (var i = 0, max = 10; i &lt; max; i += 1){…}</li>\n<li>在限定数组项的逗号后面：var a = [1, 2, 3];</li>\n<li>对象属性的逗号之后和将属性名和属性值分开的冒号之后：var o = {a: 1, b: 2};</li>\n<li>分隔开函数中各个参数的逗号之后：myFunc(a, b, c)</li>\n<li>在函数声明的大括号之前：function myFunc() {}</li>\n<li>在匿名函数表达式之后：var myFunc = function () {};</li>\n</ul>\n<p><strong>用初二</strong></p>\n<p>空格的另外一个很好的用途是用来分隔所有的操作符和操作，这也就是意味着在 +, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, += 等之后使用空格：</p>\n<p>例子：</p>\n<pre><code>//大量空格，并且使用一致，是的代码可读性更好\n//允许在阅读的时候不用一口气读下去\nvar d = 0,\n    a = b +1;\nif ( a &amp;&amp; b &amp;&amp; c) {\n    d = a % c;\n    a += d;\n}\n\n//反模式\n//缺少空格或空格使用不一致，使得代码比较混乱\nvar d= 0;\n    a =b+1;\nif (a&amp;&amp; b&amp;&amp; c) {\nd=a %c;\n    a+= d;\n}\n</code></pre><hr>\n<h2 id=\"六、编写API文档\"><a href=\"#六、编写API文档\" class=\"headerlink\" title=\"六、编写API文档\"></a>六、编写API文档</h2><h3 id=\"1-生成API文档的步骤：\"><a href=\"#1-生成API文档的步骤：\" class=\"headerlink\" title=\"1. 生成API文档的步骤：\"></a>1. 生成API文档的步骤：</h3><ul>\n<li>编写特殊格式的代码块（即一些注释块）</li>\n<li>运行工具来解析代码和注释（工具如：JSDoc Toolkit和YUIDoc）</li>\n<li>发布工具解析的结果，大多数情况是采用HTML格式发布（如网页版的API文档就是利用工具生成的）</li>\n</ul>\n<p><strong>简单举例</strong>：</p>\n<pre><code>/**\n* 翻转一个字符串\n*\n* @param  {String} 输入需要翻转的字符串\n* @return {String} 翻转后的字符串\n**/\n\nvar reverse = function (input) {\n    //...\n    return output;\n};\n</code></pre><p><strong>YUIDoc范例</strong>：</p>\n<blockquote>\n<p>完整范例：本程序由一个文件(app.js)组成，该文件仅有一个模块(myapp)。</p>\n</blockquote>\n<p>app.js:</p>\n<pre><code>/**\n* 我的javascript应用程序\n*\n* @module myapp\n*/\n\n//使用命名空间来定义一个空对象\nvar MYAPP = {};\n\n//定义一个包含两个方法(sum()和multi())的math_stuff对象\n/**\n* @namespace MYAPP\n* class math_stuff\n*/\n\nMYAPP.math_stuff = {\n    /**\n    * Sums two numbers\n    *\n    * @method sum\n    * param     {Number}    是第一个数\n    * param     {Number}    是第二个数\n    * return    {Number}    两个输入的总和\n    */\n    sum: function (a, b) {\n        return a + b;\n    },\n    /**\n    * Multiplies two numbers\n    * param     {Number}    是第一个数\n    * param     {Number}    是第二个数\n    * return    {Number}    两个输入相乘后结果\n    */\n    multi: function (a, b) {\n        return a * b;\n    }\n};\n</code></pre><p>@namespace：这里用于命名包含以上对象的全局引用的名称</p>\n<p>@class：这里有些命名不当，他实际意思是指对象或者构造函数</p>\n<p>@method：定义对象中的方法和方法名</p>\n<p>@param：列举函数所使用的参数。其中将参数类型用大括号括起来，并在其后注释参数名及描述。</p>\n<p>@return：类似于@param，这里用于描述返回值的，并且该方法没有名称。</p>\n<p>@constructor：表明这个“类”实际上是一个构造函数</p>\n<p>@property和@type描述了对象的属性。</p>\n<h3 id=\"2-编写API目的：\"><a href=\"#2-编写API目的：\" class=\"headerlink\" title=\"2. 编写API目的：\"></a>2. 编写API目的：</h3><ul>\n<li>为API编写注释不仅仅是一中提供参考文档的简便方法，而且还有其他用途——通过再次审查代码，提高代码质量。</li>\n<li>在解决问题时写出的解决方案仅仅是一个初稿。该解决方案可以给出令人期待的输出，但是该方案是否是最佳方案呢？改代码是否可读、易于理解、维护和升级呢？当您再次审视代码时您将更加确定代码哪些部分可以改进——如何使得代码更容易继续更新，移除一些不足之处等。它可以极大地帮助您创建高质量的代码。</li>\n</ul>\n<hr>\n<h2 id=\"七、推荐写法\"><a href=\"#七、推荐写法\" class=\"headerlink\" title=\"七、推荐写法\"></a>七、推荐写法</h2><ol>\n<li><p>除了三目运算，if,else等禁止简写</p>\n<pre><code>// 正确的书写\nif (true) {\n    alert(name);\n}\nconsole.log(name);\n// 不推荐的书写\nif (true)\n    alert(name);\nconsole.log(name);\n// 不推荐的书写\nif (true)\nalert(name);\nconsole.log(name)\n</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>在需要以{}闭合的代码段前增加换行，如：for if</p>\n<pre><code> // 没有换行，小的代码段无法区分\n if (wl &amp;&amp; wl.length) {\n     for (i = 0, l = wl.length; i &lt; l; ++i) {\n         p = wl[i];\n         type = Y.Lang.type(r[p]);\n         if (s.hasOwnProperty(p)) {\n             if (merge &amp;&amp; type == &apos;object&apos;) {\n                 Y.mix(r[p], s[p]);\n             } else if (ov || !(p in r)) {\n                 r[p] = s[p];\n             }\n         }\n     }\n }\n // 有了换行，逻辑清楚多了\n if (wl &amp;&amp; wl.length) {\n\n     for (i = 0, l = wl.length; i &lt; l; ++i) {\n         p = wl[i];\n         type = Y.Lang.type(r[p]);\n\n         if (s.hasOwnProperty(p)) {\n             // 处理merge逻辑\n             if (merge &amp;&amp; type == &apos;object&apos;) {\n                 Y.mix(r[p], s[p]);\n             } else if (ov || !(p in r)) {\n                 r[p] = s[p];\n             }\n         }\n     }\n }\n换行可以是空行，也可以是注释\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><p>使用Function进行类的定义，不推荐继承，如需继承采用成熟的类库实现继承</p>\n<pre><code>// 类的实现\n function Person(name) {\n     this.name = name;\n }\n\n Person.prototype.sayName = function() {\n     alert(this.name);\n };\n\n var me = new Person(&quot;Nicholas&quot;);\n\n // 将this放到局部变量self\n function Persion(name, sex) {\n     var self = this;\n\n     self.name = name;\n     self.sex = sex;\n }\n</code></pre></li>\n</ol>\n<pre><code>平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点：\n\n    function A(){\n        //...\n    }\n    function B(){\n        //...\n    }\n    B.prototype = new A();\n    B.prototype.constructor = B; //原则上，记得把这句话加上\n\n\n继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~\n</code></pre><ol start=\"4\">\n<li><p>使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象)</p>\n<pre><code>// 缓存对象\nvar getComment = function() {\n    var dom = $(&quot;#common-container&quot;),               // 缓存dom\n                appendTo = $.appendTo,                      // 缓存全局变量\n        data = this.json.data;                      // 缓存作用域链较深的对象\n}\n</code></pre></li>\n</ol>\n<pre><code>    //当需要缓存this时必须使用self变量进行缓存\n    // 缓存this\n    function Row(name) {\n        var self = this;\n\n        self.name = name;\n        $(&quot;.row&quot;).click(function() {\n            self.getName();\n        });\n    }\n\n\nself是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。\n</code></pre><ol start=\"5\">\n<li><p>使用eval，采取$.parseJSON</p>\n<p>三个原因：</p>\n<ul>\n<li>有注入风险，尤其是ajax返回数据</li>\n<li>不方便debug</li>\n<li>效率低，eval是一个执行效率很低的函数</li>\n</ul>\n<p>建议： 使用new Function来代替eval的使用，最好就别用。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"八、不规范写法\"><a href=\"#八、不规范写法\" class=\"headerlink\" title=\"八、不规范写法\"></a>八、不规范写法</h2><ol>\n<li><p>句尾没有分号</p>\n<pre><code>var isHotel = json.type == &quot;hotel&quot; ? true : false\n</code></pre></li>\n</ol>\n<pre><code>这个是要引起注意的，比如：\n\n    a = b        // 赋值\n    (function(){\n        //....\n    })()         // 自执行函数\n\n\n未加分号，结果被解析成\n\n    a = b(function(){//...})()  //将b()()返回的结果赋值给a\n</code></pre><ol start=\"2\">\n<li><p>变量命名各种各样</p>\n<pre><code>var is_hotel;\nvar isHotel;\nvar ishotel;\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><p>if 缩写</p>\n<pre><code>if (isHotel)\n    console.log(true)\nelse\n    console.log(false)\n</code></pre></li>\n</ol>\n<ol start=\"4\">\n<li><p>使用 eval</p>\n<pre><code>var json = eval(jsonText);\n</code></pre></li>\n</ol>\n<ol start=\"5\">\n<li><p>变量未定义到处都是</p>\n<pre><code>function() {\n    var isHotel = &apos;true&apos;;\n    .......\n\n    var html = isHotel ? &apos;&lt;p&gt;hotel&lt;/p&gt;&apos; : &quot;&quot;;\n}\n</code></pre></li>\n</ol>\n<ol start=\"6\">\n<li><p>超长函数</p>\n<pre><code>function() {\n    var isHotel = &apos;true&apos;;\n    //....... 此处省略500行\n    return false;\n}\n</code></pre></li>\n</ol>\n<hr>\n<h2 id=\"九、需要注意的地方\"><a href=\"#九、需要注意的地方\" class=\"headerlink\" title=\"九、需要注意的地方\"></a>九、需要注意的地方</h2><ol>\n<li><p>window.onload只能使用一次，使用多次会被最后的覆盖。</p>\n<p>解决方案：</p>\n<ul>\n<li>只引用一次window.onload</li>\n<li>使用jQuery的$(docuemnt.ready(function(){}); 可多次使用</li>\n<li>使用函数封装，代码地址</li>\n</ul>\n</li>\n<li><p>CSS放在页头引入，javascript放在页尾引入</p>\n</li>\n<li><p>在上线之前，要编译压缩代码</p>\n</li>\n<li>减少重排与重绘</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"目录导航\"><a href=\"#目录导航\" class=\"headerlink\" title=\"目录导航\"></a>目录导航</h3><ul>\n<li><a href=\"#前端javascript规范文档\">前端javascript规范文档</a><ul>\n<li><a href=\"#一规范目的\">一、规范目的</a></li>\n<li><a href=\"#二基本准则\">二、基本准则</a></li>\n<li><a href=\"#三命名规范\">三、命名规范</a><ul>\n<li><a href=\"#目的\">1. 目的</a></li>\n<li><a href=\"#变量名\">2. 变量名</a></li>\n<li><a href=\"#构造函数类命名\">3. 构造函数（类）命名</a></li>\n<li><a href=\"#普通变量命名\">4. 普通变量命名</a></li>\n<li><a href=\"#匈牙利命名法\">5. 匈牙利命名法</a></li>\n<li><a href=\"#其他前缀规范\">6. 其他前缀规范</a></li>\n<li><a href=\"#例外情况\">7. 例外情况</a></li>\n<li><a href=\"#函数命名\">8. 函数命名</a></li>\n<li><a href=\"#变量命名例子\">9. 变量命名例子</a></li>\n</ul>\n</li>\n<li><a href=\"#四编写注释\">四、编写注释</a></li>\n<li><a href=\"#五使用空格\">五、使用空格</a></li>\n<li><a href=\"#六编写api文档\">六、编写API文档</a><ul>\n<li><a href=\"#生成api文档的步骤\">1. 生成API文档的步骤：</a></li>\n<li><a href=\"#编写api目的\">2. 编写API目的：</a></li>\n</ul>\n</li>\n<li><a href=\"#七推荐写法\">七、推荐写法</a></li>\n<li><a href=\"#八不规范写法\">八、不规范写法</a></li>\n<li><a href=\"#九需要注意的地方\">九、需要注意的地方</a></li>\n<li><a href=\"#十扩展阅读\">十、扩展阅读：</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"前端javascript规范文档\"><a href=\"#前端javascript规范文档\" class=\"headerlink\" title=\"前端javascript规范文档\"></a>前端javascript规范文档</h1><blockquote>\n<p>说明：本文档为前端JS规范</p>\n</blockquote>\n<hr>\n<h2 id=\"一、规范目的\"><a href=\"#一、规范目的\" class=\"headerlink\" title=\"一、规范目的\"></a>一、规范目的</h2><p>为提高团队协作效率，便于前端后期优化维护，输出高质量的文档。</p>\n<hr>\n<h2 id=\"二、基本准则\"><a href=\"#二、基本准则\" class=\"headerlink\" title=\"二、基本准则\"></a>二、基本准则</h2><ul>\n<li>符合web标准，结构表现行为分离，兼容性优良。页面性能方面，代码要求简洁明了有序， 尽可能的减小服务器负载，保证最快的解析速度。</li>\n<li>项目的维护和二次开发可能是直接或间接的团队合作，所以创建易维护的代码是一个项目成功与否的关键，易维护的代码意味着具有如下特性：<ul>\n<li>阅读性好：如良好的注释和命名规范，有文档</li>\n<li>具有一致性：看起来如同一个人编写</li>\n<li>代码的松耦合，高度模块化：将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从html,css,js三个层面都要考虑模块化</li>\n<li>严格按照规范编写代码</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"三、命名规范\"><a href=\"#三、命名规范\" class=\"headerlink\" title=\"三、命名规范\"></a>三、命名规范</h2><h3 id=\"1-目的\"><a href=\"#1-目的\" class=\"headerlink\" title=\"1. 目的\"></a>1. 目的</h3><p>提高代码可预测性和可维护性的方法是使用命名约定，这就意味着采用一致的方法来对变量和函数进行命名。</p>\n<h3 id=\"2-变量名\"><a href=\"#2-变量名\" class=\"headerlink\" title=\"2. 变量名\"></a>2. 变量名</h3><p>变量名包括全局变量，局部变量，类变量，函数参数</p>\n<h3 id=\"3-构造函数（类）命名\"><a href=\"#3-构造函数（类）命名\" class=\"headerlink\" title=\"3. 构造函数（类）命名\"></a>3. 构造函数（类）命名</h3><p>首字母大写，驼峰式命名。</p>\n<p>JS中没有类，但是可以用new调用构造函数：var man = new Person();</p>\n<h3 id=\"4-普通变量命名\"><a href=\"#4-普通变量命名\" class=\"headerlink\" title=\"4. 普通变量命名\"></a>4. 普通变量命名</h3><p>首字母小写，驼峰式命名，匈牙利命名</p>\n<p>如：nCheckCount 表示整形的数值</p>\n<h3 id=\"5-匈牙利命名法\"><a href=\"#5-匈牙利命名法\" class=\"headerlink\" title=\"5. 匈牙利命名法\"></a>5. 匈牙利命名法</h3><p>匈牙利命名法语法：变量名＝类型＋对象描述</p>\n<ul>\n<li>类型指变量的类型</li>\n<li>对象描述指对象名字全称或名字的一部分，要求有明确含义，命名要容易记忆容易理解。</li>\n</ul>\n<p><strong>提示</strong>: 虽然JavaScript变量表面上没有类型，但是JavaScript内部还是会为变量赋予相应的类型</p>\n<p>JavaScript变量起名类型</p>\n<p>变量命名前缀</p>\n<p>举例</p>\n<p>Array 数组</p>\n<p>a</p>\n<p>aList，aGroup</p>\n<p>Boolean 逻辑</p>\n<p>b</p>\n<p>bChecked，bHasLogin</p>\n<p>Function 函数</p>\n<p>f</p>\n<p>fGetHtml，fInit</p>\n<p>Integer 数字</p>\n<p>n</p>\n<p>nPage，nTotal</p>\n<p>Object 对象</p>\n<p>o</p>\n<p>oButton，oDate</p>\n<p>Regular Expression 正则</p>\n<p>r</p>\n<p>rDomain，rEmail</p>\n<p>String 字符</p>\n<p>s</p>\n<p>sName，sHtml</p>\n<h3 id=\"6-其他前缀规范\"><a href=\"#6-其他前缀规范\" class=\"headerlink\" title=\"6. 其他前缀规范\"></a>6. 其他前缀规范</h3><p>可根据团队及项目需要增加</p>\n<ul>\n<li><p>$：表示Jquery对象</p>\n<p>例如：$Content，$Module，一种比较广泛的Jquery对象变量命名规范。</p>\n</li>\n<li><p>fn：表示函数</p>\n<p>例如：fnGetName，fnSetAge；和上面函数的前缀略有不同，改用fn来代替，个人认为fn能够更好的区分普通变量和函数变量。</p>\n</li>\n</ul>\n<h3 id=\"7-例外情况\"><a href=\"#7-例外情况\" class=\"headerlink\" title=\"7. 例外情况\"></a>7. 例外情况</h3><p>以根据项目及团队需要，设计出针对项目需要的前缀规范，从而达到团队开发协作便利的目的。</p>\n<ul>\n<li>作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr。</li>\n<li>循环变量可以简写，比如：i，j，k等。</li>\n<li>某些作为不允许修改值的变量认为是常量，全部字母都大写。例如：COPYRIGHT，PI。常量可以存在于函数中，也可以存在于全局。必须采用全大写的命名，且单词以_分割，常量通常用于ajax请求url，和一些不会改变的数据。</li>\n</ul>\n<h3 id=\"8-函数命名\"><a href=\"#8-函数命名\" class=\"headerlink\" title=\"8. 函数命名\"></a>8. 函数命名</h3><p><strong>普通函数</strong>：首字母小写，驼峰式命名，统一使用动词或者动词+名词形式</p>\n<p>例如：fnGetVersion()，fnSubmitForm()，fnInit()；涉及返回逻辑值的函数可以使用is，has，contains等表示逻辑的词语代替动词，例如：fnIsObject()，fnHasClass()，fnContainsElment()。</p>\n<p><strong>内部函数</strong>：使用_fn+动词+名词形式，内部函数必需在函数最后定义。</p>\n<p>例如：</p>\n<pre><code>function fnGetNumber(nTotal) {\n    if (nTotal &lt; 100) {\n        nTotal = 100;\n    }\n    return _fnAdd(nTotal);\n\n    function _fnAdd(nNumber) {\n        nNumber++;\n        return nNumber;\n    }\n}\nalert(fGetNumber(10)); //alert 101\n</code></pre><p><strong>对象方法与事件响应函数</strong>：对象方法命名使用fn+对象类名+动词+名词形式；</p>\n<p>例如： fnAddressGetEmail()，</p>\n<p><strong>事件响应函数</strong>：fn+触发事件对象名+事件名或者模块名</p>\n<p>例如：fnDivClick()，fnAddressSubmitButtonClick()</p>\n<p><strong>函数方法常用的动词</strong>：</p>\n<pre><code>get 获取/set 设置,\nadd 增加/remove 删除\ncreate 创建/destory 移除\nstart 启动/stop 停止\nopen 打开/close 关闭,\nread 读取/write 写入\nload 载入/save 保存,\ncreate 创建/destroy 销毁\nbegin 开始/end 结束,\nbackup 备份/restore 恢复\nimport 导入/export 导出,\nsplit 分割/merge 合并\ninject 注入/extract 提取,\nattach 附着/detach 脱离\nbind 绑定/separate 分离,\nview 查看/browse 浏览\nedit 编辑/modify 修改,\nselect 选取/mark 标记\ncopy 复制/paste 粘贴,\nundo 撤销/redo 重做\ninsert 插入/delete 移除,\nadd 加入/append 添加\nclean 清理/clear 清除,\nindex 索引/sort 排序\nfind 查找/search 搜索,\nincrease 增加/decrease 减少\nplay 播放/pause 暂停,\nlaunch 启动/run 运行\ncompile 编译/execute 执行,\ndebug 调试/trace 跟踪\nobserve 观察/listen 监听,\nbuild 构建/publish 发布\ninput 输入/output 输出,\nencode 编码/decode 解码\nencrypt 加密/decrypt 解密,\ncompress 压缩/decompress 解压缩\npack 打包/unpack 解包,\nparse 解析/emit 生成\nconnect 连接/disconnect 断开,\nsend 发送/receive 接收\ndownload 下载/upload 上传,\nrefresh 刷新/synchronize 同步\nupdate 更新/revert 复原,\nlock 锁定/unlock 解锁\ncheck out 签出/check in 签入,\nsubmit 提交/commit 交付\npush 推/pull 拉,\nexpand 展开/collapse 折叠\nbegin 起始/end 结束,\nstart 开始/finish 完成\nenter 进入/exit 退出,\nabort 放弃/quit 离开\nobsolete 废弃/depreciate 废旧,\ncollect 收集/aggregate 聚集\n</code></pre><h3 id=\"9-变量命名例子\"><a href=\"#9-变量命名例子\" class=\"headerlink\" title=\"9. 变量命名例子\"></a>9. 变量命名例子</h3><ul>\n<li><p>为什么需要这样强制定义变量前缀？正式因为javascript是弱语言造成的。在定义大量变量的时候，我们需要很明确的知道当前变量是什么属性，如果只通过普通单词，是很难区分的。</p>\n<p>普通代码</p>\n<pre><code>var checked = false;\nvar check = function() {\n    return true;\n}\n/**\nsome code\n**/\n\nif(check) {//已经无法很确切知道这里是要用checked还是check()从而导致逻辑错误\n    //do some thing\n}\n</code></pre></li>\n</ul>\n<pre><code>规范后代码\n\n    var bChecked = false;\n    var fnCheck = function() {\n        return true;\n    }\n    /**\n    some code\n    **/\n\n    if(bChecked) {\n        // do some thing\n    }\n    if(fnCheck()) {\n        // do other thing\n    }\n</code></pre><ul>\n<li><p>如何标明私有方法或私有属性？</p>\n<pre><code>var person = {\n    getName: function () {\n        return this._getFirst() + &apos; &apos; + this._getLast();\n    },\n    _getFirst: function () {\n        //...\n    },\n    _getLast: function (){\n        //...\n    } };\n</code></pre></li>\n</ul>\n<pre><code>在这个例子中，getName()以为这这是API的一个公开的方法，而\\_getFirst()和\\_getLast()意味着这是一个私有函数。尽管他们都是普通的公开方法，但是使用下划线前缀的表示方法可以提醒使用person对象的用户，告诉他们这些方法在其他地方不能确保一定能够正常工作，不能直接调用。\n</code></pre><ul>\n<li><p>总结：下面是一些使用下划线约定的变量</p>\n<ul>\n<li>使用下划线结尾来表明是私有变量，例如name_和getElements_()。</li>\n<li>使用一个下划线前缀来表示受保护属性，使用两个下划线前缀来表示私有属性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"四、编写注释\"><a href=\"#四、编写注释\" class=\"headerlink\" title=\"四、编写注释\"></a>四、编写注释</h2><blockquote>\n<p>为代码编写注释是非常重要的。通常人们在深入思考一个问题时，会非常清楚这段代码的工作原理。但是当过一周后再次回到该代码时，可能会花上很长时间来回想起那段代码到底是干什么的。</p>\n</blockquote>\n<ul>\n<li><p>公共组件维护者和各栏目WD都需要在文件头部加上注释说明：</p>\n<pre><code>/**\n*文件用途说明\n*作者姓名、联系方式（旺旺）\n*制作日期\n**/\n</code></pre></li>\n</ul>\n<ul>\n<li><p>大的模块注释方法：</p>\n<pre><code>//================\n// 代码用途\n//================\n</code></pre></li>\n</ul>\n<ul>\n<li><p>小的注释；</p>\n<pre><code>//代码说明\n</code></pre></li>\n</ul>\n<pre><code>注释单独一行，不要在代码后的同一行内加注释。例如：\n\n    //姓名\n    var name = “abc”;   V\n    var name =”abc”; //姓名 X\n</code></pre><hr>\n<h2 id=\"五、使用空格\"><a href=\"#五、使用空格\" class=\"headerlink\" title=\"五、使用空格\"></a>五、使用空格</h2><blockquote>\n<p>使用空格有助于改善代码的可读性和一致性。在撰写英文文章时在逗号和区间范围后面使用空格。在javascript采用同样的逻辑，可在列表表达式（等价于逗号）和语句结束（等价于完成一次“思考”）后面添加空格。</p>\n</blockquote>\n<p><strong>用处一</strong></p>\n<ul>\n<li>在分开for循环的各个部分的分号之后：例如，for (var i = 0; i &lt; 10; i +=1){…}</li>\n<li>在for循环中初始化多个变量（i和最大值等）：for (var i = 0, max = 10; i &lt; max; i += 1){…}</li>\n<li>在限定数组项的逗号后面：var a = [1, 2, 3];</li>\n<li>对象属性的逗号之后和将属性名和属性值分开的冒号之后：var o = {a: 1, b: 2};</li>\n<li>分隔开函数中各个参数的逗号之后：myFunc(a, b, c)</li>\n<li>在函数声明的大括号之前：function myFunc() {}</li>\n<li>在匿名函数表达式之后：var myFunc = function () {};</li>\n</ul>\n<p><strong>用初二</strong></p>\n<p>空格的另外一个很好的用途是用来分隔所有的操作符和操作，这也就是意味着在 +, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, += 等之后使用空格：</p>\n<p>例子：</p>\n<pre><code>//大量空格，并且使用一致，是的代码可读性更好\n//允许在阅读的时候不用一口气读下去\nvar d = 0,\n    a = b +1;\nif ( a &amp;&amp; b &amp;&amp; c) {\n    d = a % c;\n    a += d;\n}\n\n//反模式\n//缺少空格或空格使用不一致，使得代码比较混乱\nvar d= 0;\n    a =b+1;\nif (a&amp;&amp; b&amp;&amp; c) {\nd=a %c;\n    a+= d;\n}\n</code></pre><hr>\n<h2 id=\"六、编写API文档\"><a href=\"#六、编写API文档\" class=\"headerlink\" title=\"六、编写API文档\"></a>六、编写API文档</h2><h3 id=\"1-生成API文档的步骤：\"><a href=\"#1-生成API文档的步骤：\" class=\"headerlink\" title=\"1. 生成API文档的步骤：\"></a>1. 生成API文档的步骤：</h3><ul>\n<li>编写特殊格式的代码块（即一些注释块）</li>\n<li>运行工具来解析代码和注释（工具如：JSDoc Toolkit和YUIDoc）</li>\n<li>发布工具解析的结果，大多数情况是采用HTML格式发布（如网页版的API文档就是利用工具生成的）</li>\n</ul>\n<p><strong>简单举例</strong>：</p>\n<pre><code>/**\n* 翻转一个字符串\n*\n* @param  {String} 输入需要翻转的字符串\n* @return {String} 翻转后的字符串\n**/\n\nvar reverse = function (input) {\n    //...\n    return output;\n};\n</code></pre><p><strong>YUIDoc范例</strong>：</p>\n<blockquote>\n<p>完整范例：本程序由一个文件(app.js)组成，该文件仅有一个模块(myapp)。</p>\n</blockquote>\n<p>app.js:</p>\n<pre><code>/**\n* 我的javascript应用程序\n*\n* @module myapp\n*/\n\n//使用命名空间来定义一个空对象\nvar MYAPP = {};\n\n//定义一个包含两个方法(sum()和multi())的math_stuff对象\n/**\n* @namespace MYAPP\n* class math_stuff\n*/\n\nMYAPP.math_stuff = {\n    /**\n    * Sums two numbers\n    *\n    * @method sum\n    * param     {Number}    是第一个数\n    * param     {Number}    是第二个数\n    * return    {Number}    两个输入的总和\n    */\n    sum: function (a, b) {\n        return a + b;\n    },\n    /**\n    * Multiplies two numbers\n    * param     {Number}    是第一个数\n    * param     {Number}    是第二个数\n    * return    {Number}    两个输入相乘后结果\n    */\n    multi: function (a, b) {\n        return a * b;\n    }\n};\n</code></pre><p>@namespace：这里用于命名包含以上对象的全局引用的名称</p>\n<p>@class：这里有些命名不当，他实际意思是指对象或者构造函数</p>\n<p>@method：定义对象中的方法和方法名</p>\n<p>@param：列举函数所使用的参数。其中将参数类型用大括号括起来，并在其后注释参数名及描述。</p>\n<p>@return：类似于@param，这里用于描述返回值的，并且该方法没有名称。</p>\n<p>@constructor：表明这个“类”实际上是一个构造函数</p>\n<p>@property和@type描述了对象的属性。</p>\n<h3 id=\"2-编写API目的：\"><a href=\"#2-编写API目的：\" class=\"headerlink\" title=\"2. 编写API目的：\"></a>2. 编写API目的：</h3><ul>\n<li>为API编写注释不仅仅是一中提供参考文档的简便方法，而且还有其他用途——通过再次审查代码，提高代码质量。</li>\n<li>在解决问题时写出的解决方案仅仅是一个初稿。该解决方案可以给出令人期待的输出，但是该方案是否是最佳方案呢？改代码是否可读、易于理解、维护和升级呢？当您再次审视代码时您将更加确定代码哪些部分可以改进——如何使得代码更容易继续更新，移除一些不足之处等。它可以极大地帮助您创建高质量的代码。</li>\n</ul>\n<hr>\n<h2 id=\"七、推荐写法\"><a href=\"#七、推荐写法\" class=\"headerlink\" title=\"七、推荐写法\"></a>七、推荐写法</h2><ol>\n<li><p>除了三目运算，if,else等禁止简写</p>\n<pre><code>// 正确的书写\nif (true) {\n    alert(name);\n}\nconsole.log(name);\n// 不推荐的书写\nif (true)\n    alert(name);\nconsole.log(name);\n// 不推荐的书写\nif (true)\nalert(name);\nconsole.log(name)\n</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li><p>在需要以{}闭合的代码段前增加换行，如：for if</p>\n<pre><code> // 没有换行，小的代码段无法区分\n if (wl &amp;&amp; wl.length) {\n     for (i = 0, l = wl.length; i &lt; l; ++i) {\n         p = wl[i];\n         type = Y.Lang.type(r[p]);\n         if (s.hasOwnProperty(p)) {\n             if (merge &amp;&amp; type == &apos;object&apos;) {\n                 Y.mix(r[p], s[p]);\n             } else if (ov || !(p in r)) {\n                 r[p] = s[p];\n             }\n         }\n     }\n }\n // 有了换行，逻辑清楚多了\n if (wl &amp;&amp; wl.length) {\n\n     for (i = 0, l = wl.length; i &lt; l; ++i) {\n         p = wl[i];\n         type = Y.Lang.type(r[p]);\n\n         if (s.hasOwnProperty(p)) {\n             // 处理merge逻辑\n             if (merge &amp;&amp; type == &apos;object&apos;) {\n                 Y.mix(r[p], s[p]);\n             } else if (ov || !(p in r)) {\n                 r[p] = s[p];\n             }\n         }\n     }\n }\n换行可以是空行，也可以是注释\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><p>使用Function进行类的定义，不推荐继承，如需继承采用成熟的类库实现继承</p>\n<pre><code>// 类的实现\n function Person(name) {\n     this.name = name;\n }\n\n Person.prototype.sayName = function() {\n     alert(this.name);\n };\n\n var me = new Person(&quot;Nicholas&quot;);\n\n // 将this放到局部变量self\n function Persion(name, sex) {\n     var self = this;\n\n     self.name = name;\n     self.sex = sex;\n }\n</code></pre></li>\n</ol>\n<pre><code>平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点：\n\n    function A(){\n        //...\n    }\n    function B(){\n        //...\n    }\n    B.prototype = new A();\n    B.prototype.constructor = B; //原则上，记得把这句话加上\n\n\n继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~\n</code></pre><ol start=\"4\">\n<li><p>使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象)</p>\n<pre><code>// 缓存对象\nvar getComment = function() {\n    var dom = $(&quot;#common-container&quot;),               // 缓存dom\n                appendTo = $.appendTo,                      // 缓存全局变量\n        data = this.json.data;                      // 缓存作用域链较深的对象\n}\n</code></pre></li>\n</ol>\n<pre><code>    //当需要缓存this时必须使用self变量进行缓存\n    // 缓存this\n    function Row(name) {\n        var self = this;\n\n        self.name = name;\n        $(&quot;.row&quot;).click(function() {\n            self.getName();\n        });\n    }\n\n\nself是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。\n</code></pre><ol start=\"5\">\n<li><p>使用eval，采取$.parseJSON</p>\n<p>三个原因：</p>\n<ul>\n<li>有注入风险，尤其是ajax返回数据</li>\n<li>不方便debug</li>\n<li>效率低，eval是一个执行效率很低的函数</li>\n</ul>\n<p>建议： 使用new Function来代替eval的使用，最好就别用。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"八、不规范写法\"><a href=\"#八、不规范写法\" class=\"headerlink\" title=\"八、不规范写法\"></a>八、不规范写法</h2><ol>\n<li><p>句尾没有分号</p>\n<pre><code>var isHotel = json.type == &quot;hotel&quot; ? true : false\n</code></pre></li>\n</ol>\n<pre><code>这个是要引起注意的，比如：\n\n    a = b        // 赋值\n    (function(){\n        //....\n    })()         // 自执行函数\n\n\n未加分号，结果被解析成\n\n    a = b(function(){//...})()  //将b()()返回的结果赋值给a\n</code></pre><ol start=\"2\">\n<li><p>变量命名各种各样</p>\n<pre><code>var is_hotel;\nvar isHotel;\nvar ishotel;\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><p>if 缩写</p>\n<pre><code>if (isHotel)\n    console.log(true)\nelse\n    console.log(false)\n</code></pre></li>\n</ol>\n<ol start=\"4\">\n<li><p>使用 eval</p>\n<pre><code>var json = eval(jsonText);\n</code></pre></li>\n</ol>\n<ol start=\"5\">\n<li><p>变量未定义到处都是</p>\n<pre><code>function() {\n    var isHotel = &apos;true&apos;;\n    .......\n\n    var html = isHotel ? &apos;&lt;p&gt;hotel&lt;/p&gt;&apos; : &quot;&quot;;\n}\n</code></pre></li>\n</ol>\n<ol start=\"6\">\n<li><p>超长函数</p>\n<pre><code>function() {\n    var isHotel = &apos;true&apos;;\n    //....... 此处省略500行\n    return false;\n}\n</code></pre></li>\n</ol>\n<hr>\n<h2 id=\"九、需要注意的地方\"><a href=\"#九、需要注意的地方\" class=\"headerlink\" title=\"九、需要注意的地方\"></a>九、需要注意的地方</h2><ol>\n<li><p>window.onload只能使用一次，使用多次会被最后的覆盖。</p>\n<p>解决方案：</p>\n<ul>\n<li>只引用一次window.onload</li>\n<li>使用jQuery的$(docuemnt.ready(function(){}); 可多次使用</li>\n<li>使用函数封装，代码地址</li>\n</ul>\n</li>\n<li><p>CSS放在页头引入，javascript放在页尾引入</p>\n</li>\n<li><p>在上线之前，要编译压缩代码</p>\n</li>\n<li>减少重排与重绘</li>\n</ol>\n<hr>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjutlylg20006zcums3pisutr","category_id":"cjutlylfy0004zcum1oz5lgc4","_id":"cjutlylga000bzcum4s1l3rag"},{"post_id":"cjutlylfh0001zcumztqozr5x","category_id":"cjutlylfy0004zcum1oz5lgc4","_id":"cjutlylgb000ezcum48tq3mr4"},{"post_id":"cjutlylft0003zcum4gbmhi6w","category_id":"cjutlylfy0004zcum1oz5lgc4","_id":"cjutlylgc000gzcum7dj5s40d"},{"post_id":"cjutlylg00005zcum17qezq6o","category_id":"cjutlylfy0004zcum1oz5lgc4","_id":"cjutlylgd000jzcumwy8rw06f"}],"PostTag":[{"post_id":"cjutlylfa0000zcumnk6vcmxl","tag_id":"cjutlylfo0002zcumv036welr","_id":"cjutlylg60008zcum0yps0f60"},{"post_id":"cjutlylfh0001zcumztqozr5x","tag_id":"cjutlylg40007zcum6t6h72ae","_id":"cjutlylgb000dzcum9h9lx2hy"},{"post_id":"cjutlylft0003zcum4gbmhi6w","tag_id":"cjutlylga000azcum2xeiytb6","_id":"cjutlylgc000hzcum4kntm0t5"},{"post_id":"cjutlylg00005zcum17qezq6o","tag_id":"cjutlylga000azcum2xeiytb6","_id":"cjutlylgd000kzcumo45bpqqp"},{"post_id":"cjutlylg20006zcums3pisutr","tag_id":"cjutlylgd000izcumv7u87e0h","_id":"cjutlylge000lzcumii7leokp"}],"Tag":[{"name":"NodeJs","_id":"cjutlylfo0002zcumv036welr"},{"name":"前端工程化","_id":"cjutlylg40007zcum6t6h72ae"},{"name":"前端性能","_id":"cjutlylga000azcum2xeiytb6"},{"name":"前端规范","_id":"cjutlylgd000izcumv7u87e0h"}]}}